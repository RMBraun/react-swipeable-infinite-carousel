{"version":3,"file":"index.es.js","sources":["../src/components/Carousel.jsx"],"sourcesContent":["import React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\n// import PropTypes from 'prop-types'\n\nconst calcContainerWidth = (width, count, gap) => `calc(${width}px * ${count} + (${count - 1} * ${gap}px))`\n\nconst ContainerCss = ({ slideWidth, displayCount, minDisplayCount, gridGap }) => ({\n  position: 'relative',\n  minWidth: `${\n    minDisplayCount && minDisplayCount > 0 ? calcContainerWidth(slideWidth, minDisplayCount, gridGap) : 'auto'\n  }`,\n  width: `${displayCount && displayCount > 0 ? calcContainerWidth(slideWidth, displayCount, gridGap) : '100%'}`,\n  maxWidth: '100%',\n  overflow: 'hidden',\n  display: 'flex',\n  flexDirection: 'row',\n  alignItems: 'center',\n})\n\nconst SlidesContainerCss = ({ gridGap, isScrolling, isDragging }) => ({\n  display: 'flex',\n  flexDirection: 'row',\n  gap: `${gridGap}px`,\n  zIndex: 1,\n  transition: `transform ${isScrolling || isDragging ? '0ms' : '500ms'}`,\n})\n\nconst ArrowIconCss = {\n  width: '35%',\n  height: '35%',\n  border: '6px solid #1b1b1b',\n  borderRadius: '5px',\n  transition: 'border-color 500ms',\n}\n\nconst ArrowCss = ({ size }) => ({\n  position: 'absolute',\n  display: 'flex',\n  flexDirection: 'column',\n  justifyContent: 'center',\n  alignItems: 'center',\n  padding: '0px',\n  margin: '0px',\n  border: 'none',\n  width: `${size}px`,\n  height: `${size}px`,\n  borderRadius: '50%',\n  backgroundColor: 'transparent',\n  transition: 'opacity 500ms, background-color 500ms',\n  zIndex: '2',\n  cursor: 'pointer',\n})\n\nconst LeftArrowCSs = (props) => ({\n  ...ArrowCss(props),\n  left: '10px',\n})\n\nconst LeftArrowIconCss = {\n  ...ArrowIconCss,\n  borderRight: 'none',\n  borderTop: 'none',\n  transform: 'translateX(2.5px) rotate(45deg)',\n}\n\nconst RightArrowCss = (props) => ({\n  ...ArrowCss(props),\n  right: '10px',\n})\n\nconst RightArrowIconCss = {\n  ...ArrowIconCss,\n  borderLeft: 'none',\n  borderBottom: 'none',\n  transform: 'translateX(-2.5px) rotate(45deg)',\n}\n\nconst Arrow = ({ isLeft, isHidden, style, onClick }) => {\n  const [isHover, setIsHover] = useState(false)\n  const [isActive, setIsActive] = useState(false)\n\n  return (\n    <button\n      style={{\n        ...style,\n        opacity: isHidden ? '0' : isHover ? '1' : '0.5',\n        pointerEvents: `${isHidden ? 'none' : 'auto'}`,\n        backgroundColor: isActive ? '#929292a9' : isHover ? '#efefefa9' : 'transparent',\n      }}\n      onClick={onClick}\n      onMouseEnter={() => setIsHover(true)}\n      onMouseLeave={() => {\n        setIsHover(false)\n        setIsActive(false)\n      }}\n      onMouseDown={() => setIsActive(true)}\n      onMouseUp={() => setIsActive(false)}\n    >\n      <span style={isLeft ? LeftArrowIconCss : RightArrowIconCss} />\n    </button>\n  )\n}\n\n// Arrow.propTypes = {\n//   isLeft: PropTypes.bool,\n//   isHidden: PropTypes.bool,\n//   style: PropTypes.object,\n//   onClick: PropTypes.func,\n// }\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nexport const Carousel = ({\n  startIndex = 0,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  slideWidth,\n  showArrows = true,\n  renderArrows: RenderArrows = Arrow,\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const slides = useMemo(() => React.Children.toArray(children) || [], [children])\n\n  const slideCount = useMemo(() => slides.length, [slides])\n\n  const slidesRefs = useMemo(() => Array(slideCount).fill(React.createRef()), [slideCount])\n\n  const containerRef = useRef(null)\n  const slideContainerRef = useRef(null)\n\n  const [maxDisplayCount, setMaxDisplayCount] = useState(Math.max(displayCount, 1))\n\n  const getTranslateOffset = useCallback(\n    (newIndex, scrollDelta = 0) => {\n      return newIndex * -1 * (slideWidth + gridGap) - scrollDelta\n    },\n\n    [slideWidth, gridGap],\n  )\n\n  const [index, setIndex] = useState(startIndex)\n  const [isDragging, setIsDragging] = useState(false)\n  const [isScrolling, setIsScrolling] = useState(false)\n  const translateOffset = useRef(getTranslateOffset(index, 0))\n\n  const setTranslateOffset = useCallback((offset) => {\n    translateOffset.current = offset\n    requestAnimationFrame(() => {\n      if (slideContainerRef.current) {\n        slideContainerRef.current.style.transform = `translate(${offset}px)`\n      }\n    })\n  }, [])\n\n  const touchStartRef = useRef(0)\n  const touchEndRef = useRef(0)\n  const scrollDebounceId = useRef()\n  const lastScrollInfo = useRef({\n    timestamp: 0,\n  })\n\n  const onResize = useCallback(() => {\n    const containerWidth = containerRef.current?.clientWidth || slideCount * slideWidth\n\n    const boundMaxDisplayCount = Math.max(Math.min(Math.floor(containerWidth / slideWidth), displayCount), 1)\n\n    const newBoundIndex =\n      index < 0 ? 0 : index > slideCount - boundMaxDisplayCount ? slideCount - boundMaxDisplayCount : index\n\n    const newBoundScrollDelta = getTranslateOffset(newBoundIndex, 0)\n\n    setTranslateOffset(newBoundScrollDelta)\n    setMaxDisplayCount(boundMaxDisplayCount)\n  }, [slideCount, slideWidth, index, displayCount, getTranslateOffset, setTranslateOffset, setMaxDisplayCount])\n\n  const getNewScrollState = useCallback(\n    (newIndex) => {\n      const newBoundIndex =\n        newIndex < 0 ? 0 : newIndex > slideCount - maxDisplayCount ? slideCount - maxDisplayCount : newIndex\n\n      const newBoundScrollDelta = getTranslateOffset(newBoundIndex, 0)\n\n      return {\n        index: newBoundIndex,\n        translateOffset: newBoundScrollDelta,\n      }\n    },\n    [slideCount, maxDisplayCount, getTranslateOffset],\n  )\n\n  useLayoutEffect(() => {\n    onResize()\n  }, [slideCount, minDisplayCount, displayCount, gridGap, slideWidth])\n\n  useEffect(() => {\n    window.addEventListener('resize', onResize)\n\n    return () => {\n      window.removeEventListener('resize', onResize)\n    }\n  }, [onResize])\n\n  const maxScrollX = 0\n  const minScrollX = useMemo(\n    () => -1 * (slideCount - maxDisplayCount) * (slideWidth + gridGap),\n    [slideCount, maxDisplayCount, slideWidth, gridGap],\n  )\n\n  const showLeftArrow = index !== 0\n  const showRightArrow = index + maxDisplayCount < slideCount\n\n  const onArrowClick = useCallback(\n    (indexOffset) => (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      const newIndex = index + indexOffset\n      const newBoundIndex =\n        newIndex < 0 ? 0 : newIndex > slideCount - maxDisplayCount ? slideCount - maxDisplayCount - 1 : newIndex\n\n      setIndex(newBoundIndex)\n      setTranslateOffset(getTranslateOffset(newBoundIndex, 0))\n    },\n    [index, slideCount, maxDisplayCount, getTranslateOffset, setIndex, setTranslateOffset],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (!isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n\n      if (delta !== 0) {\n        const newScrollDelta = getTranslateOffset(index, delta)\n\n        setTranslateOffset(newScrollDelta)\n      }\n    },\n    [isScrolling, isDragging, index, setTranslateOffset, getTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      const delta = touchStartRef.current - touchEndRef.current\n\n      if (delta !== 0) {\n        const newIndex = Math.round(index + delta / (slideWidth + gridGap))\n\n        const newScrollState = getNewScrollState(newIndex)\n\n        setIndex(newScrollState.index)\n        setTranslateOffset(newScrollState.translateOffset)\n\n        touchStartRef.current = 0\n        touchEndRef.current = 0\n      }\n\n      setIsDragging(false)\n    },\n    [isScrolling, index, slideWidth, gridGap, setIndex, setTranslateOffset, getNewScrollState],\n  )\n\n  const onScroll = useCallback(\n    (e) => {\n      if (isDragging) {\n        return\n      }\n\n      const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = isWheel ? -1 * e.deltaY : e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      lastScrollInfo.current.timestamp = e.timeStamp\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        return\n      }\n\n      if (!isScrolling && !isWheel) {\n        setIsScrolling(true)\n      }\n\n      const newScrollDelta = translateOffset.current - scrollDirection * Math.min(slideWidth, Math.abs(scrollDelta))\n\n      const debounceFunc = () => {\n        setIsScrolling(false)\n\n        const newIndex = Math.round(Math.abs(newScrollDelta) / (slideWidth + gridGap))\n\n        const newScrollState = getNewScrollState(newIndex)\n\n        setIndex(newScrollState.index)\n        setTranslateOffset(newScrollState.translateOffset)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (newScrollDelta >= maxScrollX) {\n        setTranslateOffset(maxScrollX)\n        debounceFunc()\n      } else if (newScrollDelta <= minScrollX) {\n        setTranslateOffset(minScrollX)\n        debounceFunc()\n      } else {\n        setTranslateOffset(newScrollDelta)\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      gridGap,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      slideWidth,\n      isDragging,\n      setIsScrolling,\n      setIndex,\n      setTranslateOffset,\n      getNewScrollState,\n    ],\n  )\n\n  return (\n    <div\n      style={{\n        ...ContainerCss({\n          minDisplayCount,\n          displayCount,\n          slideWidth,\n          gridGap,\n        }),\n        ...style,\n      }}\n      ref={containerRef}\n    >\n      {showArrows && (\n        <RenderArrows\n          isLeft={true}\n          isRight={false}\n          style={LeftArrowCSs({\n            size: 48,\n          })}\n          isHidden={isScrolling || isDragging || !showLeftArrow}\n          onClick={showLeftArrow ? onArrowClick(-1) : undefined}\n        />\n      )}\n      <div\n        ref={slideContainerRef}\n        style={{\n          ...SlidesContainerCss({\n            gridGap,\n            isScrolling,\n            isDragging,\n          }),\n          ...slideContainerStyle,\n        }}\n        onTouchStart={onTouchStart}\n        onTouchMove={onTouchMove}\n        onTouchEnd={onTouchEnd}\n        onTouchCancel={onTouchEnd}\n        onMouseDown={onTouchStart}\n        onMouseMove={onTouchMove}\n        onMouseUp={onTouchEnd}\n        onMouseLeave={onTouchEnd}\n        onWheel={onScroll}\n      >\n        {slides.map((slide, i) => (\n          <div style={slideStyle} ref={slidesRefs[i]} key={i}>\n            {slide}\n          </div>\n        ))}\n      </div>\n      {showArrows && (\n        <RenderArrows\n          isLeft={false}\n          isRight={true}\n          style={RightArrowCss({\n            size: 48,\n          })}\n          isHidden={isScrolling || isDragging || !showRightArrow}\n          onClick={showRightArrow ? onArrowClick(1) : undefined}\n        />\n      )}\n    </div>\n  )\n}\n\n// Carousel.propTypes = {\n//   startIndex: PropTypes.number,\n//   minDisplayCount: PropTypes.number,\n//   displayCount: PropTypes.number,\n//   gridGap: PropTypes.number,\n//   slideWidth: PropTypes.number,\n//   showArrows: PropTypes.bool,\n//   renderArrows: PropTypes.node,\n//   style: PropTypes.object,\n//   slideContainerStyle: PropTypes.object,\n//   slideStyle: PropTypes.object,\n//   children: PropTypes.node,\n// }\n"],"names":["calcContainerWidth","width","count","gap","ContainerCss","slideWidth","displayCount","minDisplayCount","gridGap","position","minWidth","maxWidth","overflow","display","flexDirection","alignItems","SlidesContainerCss","isScrolling","isDragging","zIndex","transition","ArrowIconCss","height","border","borderRadius","ArrowCss","size","justifyContent","padding","margin","backgroundColor","cursor","LeftArrowIconCss","borderRight","borderTop","transform","RightArrowCss","props","right","RightArrowIconCss","borderLeft","borderBottom","Arrow","isLeft","isHidden","style","onClick","isHover","setIsHover","useState","isActive","setIsActive","React","createElement","opacity","pointerEvents","onMouseEnter","onMouseLeave","onMouseDown","onMouseUp","getClientXOffset","e","touches","clientX","Carousel","startIndex","showArrows","renderArrows","RenderArrows","slideContainerStyle","slideStyle","children","slides","useMemo","Children","toArray","slideCount","length","slidesRefs","Array","fill","createRef","containerRef","useRef","slideContainerRef","maxDisplayCount","setMaxDisplayCount","Math","max","getTranslateOffset","useCallback","newIndex","scrollDelta","index","setIndex","setIsDragging","setIsScrolling","translateOffset","setTranslateOffset","offset","current","requestAnimationFrame","touchStartRef","touchEndRef","scrollDebounceId","lastScrollInfo","timestamp","onResize","containerWidth","clientWidth","boundMaxDisplayCount","min","floor","newBoundScrollDelta","getNewScrollState","newBoundIndex","useLayoutEffect","useEffect","window","addEventListener","removeEventListener","minScrollX","showLeftArrow","showRightArrow","onArrowClick","indexOffset","preventDefault","stopPropagation","onTouchStart","xOffset","onTouchMove","delta","newScrollDelta","onTouchEnd","round","newScrollState","onScroll","isWheel","deltaX","abs","deltaY","scrollDirection","sign","timeStamp","debounceFunc","clearTimeout","setTimeout","ref","isRight","left","undefined","onTouchCancel","onMouseMove","onWheel","map","slide","i","key"],"mappings":"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"}