{"version":3,"file":"index.es.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/components/Carousel.jsx"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\nimport styles from './Carousel.module.css'\n\nconst calcContainerWidth = (width, count, gap) => `calc(${width}px * ${count} + (${count - 1} * ${gap}px))`\n\nconst ContainerCss = ({ slideWidth, displayCount, minDisplayCount, gridGap }) => ({\n  minWidth: `${\n    minDisplayCount && minDisplayCount > 0 ? calcContainerWidth(slideWidth, minDisplayCount, gridGap) : 'auto'\n  }`,\n  width: `${displayCount && displayCount > 0 ? calcContainerWidth(slideWidth, displayCount, gridGap) : '100%'}`,\n})\n\nconst SlidesContainerCss = ({ gridGap, isScrolling, isDragging }) => ({\n  gap: `${gridGap}px`,\n  transition: `transform ${isScrolling || isDragging ? '0ms' : '500ms'}`,\n})\n\nconst Arrow = ({ isLeft, isHidden, style, onClick }) => {\n  return (\n    <button\n      className={`${styles.arrow} ${isLeft ? styles.leftArrow : styles.rightArrow} ${\n        isHidden ? styles.isArrowHidden : ''\n      }`}\n      style={style}\n      onClick={onClick}\n    >\n      <span className={`${styles.arrowIcon} ${isLeft ? styles.leftArrowIcon : styles.rightArrowIcon}`} />\n    </button>\n  )\n}\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nexport const Carousel = ({\n  startIndex = 0,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  slideWidth = 0,\n  showArrows = true,\n  renderArrows: RenderArrows = Arrow,\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const slides = useMemo(() => React.Children.toArray(children) || [], [children])\n\n  const slideCount = useMemo(() => slides.length, [slides])\n\n  const slidesRefs = useMemo(() => Array(slideCount).fill(React.createRef()), [slideCount])\n\n  const containerRef = useRef(null)\n  const slideContainerRef = useRef(null)\n\n  const [maxDisplayCount, setMaxDisplayCount] = useState(Math.max(displayCount, 1))\n\n  const getTranslateOffset = useCallback(\n    (newIndex, scrollDelta = 0) => {\n      return newIndex * -1 * (slideWidth + gridGap) - scrollDelta\n    },\n\n    [slideWidth, gridGap],\n  )\n\n  const [index, setIndex] = useState(startIndex)\n  const [isDragging, setIsDragging] = useState(false)\n  const [isScrolling, setIsScrolling] = useState(false)\n  const translateOffset = useRef(getTranslateOffset(index, 0))\n\n  const setTranslateOffset = useCallback((offset) => {\n    translateOffset.current = offset\n    requestAnimationFrame(() => {\n      if (slideContainerRef.current) {\n        slideContainerRef.current.style.transform = `translate(${offset}px)`\n      }\n    })\n  }, [])\n\n  const touchStartRef = useRef(0)\n  const touchEndRef = useRef(0)\n  const scrollDebounceId = useRef()\n  const lastScrollInfo = useRef({\n    timestamp: 0,\n  })\n\n  const onResize = useCallback(() => {\n    const containerWidth = containerRef.current?.clientWidth || slideCount * slideWidth\n\n    const boundMaxDisplayCount = Math.max(Math.min(Math.floor(containerWidth / slideWidth), displayCount), 1)\n\n    const newBoundIndex =\n      index < 0 ? 0 : index > slideCount - boundMaxDisplayCount ? slideCount - boundMaxDisplayCount : index\n\n    const newBoundScrollDelta = getTranslateOffset(newBoundIndex, 0)\n\n    setTranslateOffset(newBoundScrollDelta)\n    setMaxDisplayCount(boundMaxDisplayCount)\n  }, [slideCount, slideWidth, index, displayCount, getTranslateOffset, setTranslateOffset, setMaxDisplayCount])\n\n  const getNewScrollState = useCallback(\n    (newIndex) => {\n      const newBoundIndex =\n        newIndex < 0 ? 0 : newIndex > slideCount - maxDisplayCount ? slideCount - maxDisplayCount : newIndex\n\n      const newBoundScrollDelta = getTranslateOffset(newBoundIndex, 0)\n\n      return {\n        index: newBoundIndex,\n        translateOffset: newBoundScrollDelta,\n      }\n    },\n    [slideCount, maxDisplayCount, getTranslateOffset],\n  )\n\n  useLayoutEffect(() => {\n    onResize()\n  }, [slideCount, minDisplayCount, displayCount, gridGap, slideWidth])\n\n  useEffect(() => {\n    window.addEventListener('resize', onResize)\n\n    return () => {\n      window.removeEventListener('resize', onResize)\n    }\n  }, [onResize])\n\n  const maxScrollX = 0\n  const minScrollX = useMemo(\n    () => -1 * (slideCount - maxDisplayCount) * (slideWidth + gridGap),\n    [slideCount, maxDisplayCount, slideWidth, gridGap],\n  )\n\n  const showLeftArrow = index !== 0\n  const showRightArrow = index + maxDisplayCount < slideCount\n\n  const onArrowClick = useCallback(\n    (indexOffset) => (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      const newIndex = index + indexOffset\n      const newBoundIndex =\n        newIndex < 0 ? 0 : newIndex > slideCount - maxDisplayCount ? slideCount - maxDisplayCount - 1 : newIndex\n\n      setIndex(newBoundIndex)\n      setTranslateOffset(getTranslateOffset(newBoundIndex, 0))\n    },\n    [index, slideCount, maxDisplayCount, getTranslateOffset, setIndex, setTranslateOffset],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (!isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n\n      if (delta !== 0) {\n        const newScrollDelta = getTranslateOffset(index, delta)\n\n        setTranslateOffset(newScrollDelta)\n      }\n    },\n    [isScrolling, isDragging, index, setTranslateOffset, getTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      const delta = touchStartRef.current - touchEndRef.current\n\n      if (delta !== 0) {\n        const newIndex = Math.round(index + delta / (slideWidth + gridGap))\n\n        const newScrollState = getNewScrollState(newIndex)\n\n        setIndex(newScrollState.index)\n        setTranslateOffset(newScrollState.translateOffset)\n\n        touchStartRef.current = 0\n        touchEndRef.current = 0\n      }\n\n      setIsDragging(false)\n    },\n    [isScrolling, index, slideWidth, gridGap, setIndex, setTranslateOffset, getNewScrollState],\n  )\n\n  const onScroll = useCallback(\n    (e) => {\n      if (isDragging) {\n        return\n      }\n\n      const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = isWheel ? -1 * e.deltaY : e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      lastScrollInfo.current.timestamp = e.timeStamp\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        return\n      }\n\n      if (!isScrolling && !isWheel) {\n        setIsScrolling(true)\n      }\n\n      const newScrollDelta = translateOffset.current - scrollDirection * Math.min(slideWidth, Math.abs(scrollDelta))\n\n      const debounceFunc = () => {\n        setIsScrolling(false)\n\n        const newIndex = Math.round(Math.abs(newScrollDelta) / (slideWidth + gridGap))\n\n        const newScrollState = getNewScrollState(newIndex)\n\n        setIndex(newScrollState.index)\n        setTranslateOffset(newScrollState.translateOffset)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (newScrollDelta >= maxScrollX) {\n        setTranslateOffset(maxScrollX)\n        debounceFunc()\n      } else if (newScrollDelta <= minScrollX) {\n        setTranslateOffset(minScrollX)\n        debounceFunc()\n      } else {\n        setTranslateOffset(newScrollDelta)\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      gridGap,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      slideWidth,\n      isDragging,\n      setIsScrolling,\n      setIndex,\n      setTranslateOffset,\n      getNewScrollState,\n    ],\n  )\n\n  return (\n    <div\n      className={styles.container}\n      style={{\n        ...ContainerCss({\n          minDisplayCount,\n          displayCount,\n          slideWidth,\n          gridGap,\n        }),\n        ...style,\n      }}\n      ref={containerRef}\n    >\n      {showArrows && (\n        <RenderArrows\n          isLeft={true}\n          isRight={false}\n          isHidden={isScrolling || isDragging || !showLeftArrow}\n          onClick={showLeftArrow ? onArrowClick(-1) : undefined}\n        />\n      )}\n      <div\n        ref={slideContainerRef}\n        className={styles.slideContainer}\n        style={{\n          ...SlidesContainerCss({\n            gridGap,\n            isScrolling,\n            isDragging,\n          }),\n          ...slideContainerStyle,\n        }}\n        onTouchStart={onTouchStart}\n        onTouchMove={onTouchMove}\n        onTouchEnd={onTouchEnd}\n        onTouchCancel={onTouchEnd}\n        onMouseDown={onTouchStart}\n        onMouseMove={onTouchMove}\n        onMouseUp={onTouchEnd}\n        onMouseLeave={onTouchEnd}\n        onWheel={onScroll}\n      >\n        {slides.map((slide, i) => (\n          <div style={slideStyle} ref={slidesRefs[i]} key={i}>\n            {slide}\n          </div>\n        ))}\n      </div>\n      {showArrows && (\n        <RenderArrows\n          isLeft={false}\n          isRight={true}\n          isHidden={isScrolling || isDragging || !showRightArrow}\n          onClick={showRightArrow ? onArrowClick(1) : undefined}\n        />\n      )}\n    </div>\n  )\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","calcContainerWidth","width","count","gap","ContainerCss","slideWidth","displayCount","minDisplayCount","gridGap","minWidth","SlidesContainerCss","isScrolling","isDragging","transition","Arrow","isLeft","isHidden","onClick","React","className","styles","getClientXOffset","e","touches","clientX","Carousel","startIndex","showArrows","renderArrows","RenderArrows","slideContainerStyle","slideStyle","children","slides","useMemo","Children","toArray","slideCount","length","slidesRefs","Array","fill","createRef","containerRef","useRef","slideContainerRef","maxDisplayCount","setMaxDisplayCount","useState","Math","max","getTranslateOffset","useCallback","newIndex","scrollDelta","index","setIndex","setIsDragging","setIsScrolling","translateOffset","setTranslateOffset","offset","current","requestAnimationFrame","transform","touchStartRef","touchEndRef","scrollDebounceId","lastScrollInfo","timestamp","onResize","containerWidth","clientWidth","boundMaxDisplayCount","min","floor","newBoundScrollDelta","getNewScrollState","newBoundIndex","useLayoutEffect","useEffect","window","addEventListener","removeEventListener","minScrollX","showLeftArrow","showRightArrow","onArrowClick","indexOffset","preventDefault","stopPropagation","onTouchStart","xOffset","onTouchMove","delta","newScrollDelta","onTouchEnd","round","newScrollState","onScroll","isWheel","deltaX","abs","deltaY","scrollDirection","sign","timeStamp","debounceFunc","clearTimeout","setTimeout","isRight","undefined","onTouchCancel","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onWheel","map","slide","i","key"],"mappings":"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"}