{"version":3,"file":"index.es.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/components/Carousel.jsx","../src/components/Arrows.jsx","../src/components/Indexes.jsx"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/* eslint-disable react/prop-types */\nimport React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\nimport styles from './Carousel.module.css'\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nconst calculateAnchors = (slideRefs = [], gridGap, isInfinite) =>\n  slideRefs.reduce((acc, ref, i) => {\n    if (ref?.current) {\n      const width = ref.current.clientWidth - (!isInfinite && i === slideRefs.length - 1 ? 0 : gridGap)\n      const start = i === 0 ? 0 : acc[i - 1].end + gridGap\n      const end = start + width\n      acc.push({ start, end, width, index: i })\n    }\n    return acc\n  }, [])\n\nconst calcMinWidth = (slideAnchors, count) =>\n  slideAnchors?.length && count && count > 0\n    ? slideAnchors.reduce((acc, { start }, i) => {\n        const groupWidth = slideAnchors[Math.min(i + count - 1, slideAnchors.length - 1)].end - start\n\n        return groupWidth > acc ? groupWidth : acc\n      }, 0)\n    : 0\n\nconst ContainerCss = ({ displayCount, minDisplayCount, slideAnchors }) => {\n  const minWidth = calcMinWidth(slideAnchors, minDisplayCount)\n  const width = calcMinWidth(slideAnchors, displayCount)\n\n  return {\n    minWidth: minWidth > 0 ? `${minWidth}px` : 'auto',\n    width: width > 0 ? `${width}px` : '100%',\n  }\n}\n\nexport const Carousel = ({\n  isInfinite = false,\n  startIndex = 0,\n  isScrollable = true,\n  isDraggable = true,\n  hasDragMomentum = true,\n  dragMomentumSpeed = 25,\n  dragMomentumDecay = 0.98,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  arrows: RenderArrows,\n  arrowLeftProps = {},\n  arrowRightProps = {},\n  scrollSpeed = 75,\n  scrollCount = 1,\n  shouldScrollByDisplayCount = true,\n  indexesPerRow = 0,\n  indexes: RenderIndexes,\n  indexContainerProps = {},\n  indexProps = {},\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const [isHovering, setIsHovering] = useState(false)\n\n  const momentumDebounceId = useRef()\n\n  const transitionDebounceId = useRef()\n\n  const areArrowsLocked = useRef(false)\n\n  const currentDragSpeed = useRef(0)\n\n  const resizeObserverRef = useRef()\n\n  const rawSlides = React.Children.toArray(children) || []\n\n  const [clonesLength, setClonesLength] = useState(isInfinite ? rawSlides.length : 0)\n\n  const slides = useMemo(\n    () =>\n      isInfinite && clonesLength\n        ? [\n            ...rawSlides.slice(rawSlides.length - clonesLength, rawSlides.length),\n            ...rawSlides,\n            ...rawSlides.slice(0, clonesLength),\n          ]\n        : rawSlides,\n    [children, rawSlides.length, isInfinite, clonesLength],\n  )\n\n  const slideCount = slides.length\n\n  const slidesRefs = useMemo(\n    () =>\n      Array(slideCount)\n        .fill(null)\n        .map((_, i) => (typeof slidesRefs !== 'undefined' ? slidesRefs[i] : null) || React.createRef()),\n    [slideCount],\n  )\n\n  const [slideAnchors, setSlideAnchors] = useState([])\n\n  const coreSlideAnchors = useMemo(\n    () => (isInfinite ? slideAnchors.slice(clonesLength, slideAnchors.length - clonesLength) : slideAnchors),\n    [slideAnchors, slideAnchors.length, isInfinite],\n  )\n\n  const minTabIndex = useMemo(\n    () => coreSlideAnchors[0]?.index || clonesLength,\n    [coreSlideAnchors, coreSlideAnchors.length],\n  )\n  const maxTabIndex = useMemo(\n    () => coreSlideAnchors[coreSlideAnchors.length - 1]?.index || clonesLength + rawSlides.length - 1,\n    [coreSlideAnchors, coreSlideAnchors.length],\n  )\n\n  const containerRef = useRef(null)\n\n  const slideContainerRef = useRef(null)\n\n  const slidesOuterContainerRef = useRef(null)\n\n  const getTranslateOffset = useCallback(\n    (newIndex, newSlideAnchors = slideAnchors) => {\n      const start = newSlideAnchors?.[newIndex]?.start\n      return start != null ? -1 * start : 0\n    },\n\n    [slideAnchors],\n  )\n\n  const [index, setIndexState] = useState({ left: startIndex + clonesLength, right: startIndex + clonesLength })\n\n  const activeIndexes = useMemo(() => {\n    if (index?.left != null && index?.right != null) {\n      return Array(index.right - index.left + 1)\n        .fill(index.left)\n        .map((_, i) => (index.left + i - clonesLength) % rawSlides.length)\n    } else {\n      return []\n    }\n  }, [index?.left, index?.right, clonesLength])\n\n  const arrowScrollCount = useMemo(\n    () =>\n      isInfinite ? 1 : shouldScrollByDisplayCount ? activeIndexes.length : Math.min(activeIndexes.length, scrollCount),\n    [isInfinite, shouldScrollByDisplayCount, activeIndexes, activeIndexes.length, scrollCount],\n  )\n\n  const [maxIndex, setMaxIndex] = useState(slideCount - 1)\n\n  const [isDragging, setIsDragging] = useState(false)\n\n  const [isScrolling, setIsScrolling] = useState(true)\n\n  const isMomentum = useRef(false)\n\n  const translateOffset = useRef(() => getTranslateOffset(index.left))\n\n  const touchStartRef = useRef(0)\n\n  const touchEndRef = useRef(0)\n\n  const scrollDebounceId = useRef()\n\n  const maxScrollX = 0\n\n  const minScrollX = useMemo(() => {\n    const start = slideAnchors?.[maxIndex]?.start\n\n    return start != null ? -1 * start : 0\n  }, [slideAnchors, slideCount, maxIndex])\n\n  const showLeftArrow = isInfinite || index.left !== 0\n\n  const showRightArrow = isInfinite || index.left < maxIndex\n\n  const getBoundIndex = useCallback(\n    (newIndex, newMaxIndex = maxIndex) => Math.max(0, Math.min(newMaxIndex, newIndex)),\n    [maxIndex],\n  )\n\n  const getScrollIndex = useCallback(\n    (newTranslateOffset, newSlideAnchors = slideAnchors) => {\n      const currentOffset = -1 * newTranslateOffset\n\n      const newIndex = newSlideAnchors.reduce(\n        (acc, { start, end, width }, i) => {\n          acc.left = currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc.left\n          acc.right =\n            containerRef.current != null\n              ? currentOffset + containerRef.current.clientWidth >= end\n                ? i\n                : acc.right\n              : slideCount - 1\n\n          return acc\n        },\n        {\n          left: 0,\n          right: 0,\n        },\n      )\n\n      return {\n        left: getBoundIndex(newIndex.left),\n        right: Math.max(Math.min(slideCount - 1, newIndex.right), newIndex.left),\n      }\n    },\n    [slideCount, slideAnchors, getBoundIndex],\n  )\n\n  const setTranslateOffset = useCallback(\n    ({ offset, index, newSlideAnchors = slideAnchors, newClonesLength = clonesLength }) => {\n      requestAnimationFrame(() => {\n        if (!slideContainerRef.current) {\n          return\n        }\n\n        let boundOffset = offset\n\n        if (isInfinite && newClonesLength && newSlideAnchors.length) {\n          const rightAnchor = newSlideAnchors[newSlideAnchors.length - newClonesLength - 1].end + gridGap\n          const leftAnchor = newSlideAnchors[newClonesLength].start\n\n          if (offset + rightAnchor < 0) {\n            boundOffset = offset + rightAnchor - leftAnchor\n          } else if (offset + leftAnchor > 0) {\n            boundOffset = offset + leftAnchor - rightAnchor\n          }\n        }\n\n        const newIndex = index == null ? getScrollIndex(boundOffset) : index\n\n        if (transitionDebounceId.current) {\n          cancelAnimationFrame(transitionDebounceId.current)\n        }\n\n        if (isScrolling || isDragging) {\n          slideContainerRef.current.style.transitionDuration = '0ms'\n        }\n\n        slideContainerRef.current.style.transform = `translate(${boundOffset}px)`\n\n        transitionDebounceId.current = requestAnimationFrame(() => {\n          slideContainerRef.current.style.transitionDuration = '500ms'\n        })\n\n        translateOffset.current = boundOffset\n        setIndexState(newIndex)\n      })\n    },\n    [\n      gridGap,\n      isScrolling,\n      isDragging,\n      slideAnchors,\n      slideAnchors?.length,\n      clonesLength,\n      getScrollIndex,\n      setIndexState,\n      getScrollIndex,\n    ],\n  )\n\n  const calcClonesLength = (newSlideAnchors) => {\n    if (!isInfinite) {\n      return 0\n    }\n\n    const containerWidth = slideContainerRef.current.clientWidth\n\n    const coreSlideAnchors = isInfinite\n      ? newSlideAnchors.slice(clonesLength, newSlideAnchors.length - clonesLength)\n      : newSlideAnchors\n\n    const leftCount = coreSlideAnchors.reduce(\n      (acc, { width }, i) => {\n        acc.width = acc.width + width\n\n        if (acc.index == null && acc.width > containerWidth) {\n          acc.index = i + 1\n        }\n\n        return acc\n      },\n      {\n        width: 0,\n        index: null,\n      },\n    ).index\n\n    const rightCount = coreSlideAnchors.reduceRight(\n      (acc, { width }, i) => {\n        acc.width = acc.width + width\n\n        if (acc.index == null && acc.width > containerWidth) {\n          acc.index = coreSlideAnchors.length - i\n        }\n\n        return acc\n      },\n      {\n        width: 0,\n        index: null,\n      },\n    ).index\n\n    return Math.max(leftCount, rightCount, 1)\n  }\n\n  const onResize = () => {\n    const newSlideAnchors = calculateAnchors(slidesRefs, gridGap, isInfinite)\n    if (newSlideAnchors?.length) {\n      const containerWidth = slideContainerRef.current.clientWidth\n\n      const newClonesLength = calcClonesLength(newSlideAnchors)\n\n      const lastEnd = newSlideAnchors[newSlideAnchors.length - 1].end\n\n      const newMaxIndex = getBoundIndex(\n        newSlideAnchors.findIndex(({ start }) => start + containerWidth >= lastEnd),\n        newSlideAnchors.length - 1,\n      )\n\n      const newLeftIndex = getBoundIndex(index.left - clonesLength + newClonesLength, newMaxIndex)\n      const newTranslateOffset = getTranslateOffset(newLeftIndex, newSlideAnchors)\n      const newScrollIndex = getScrollIndex(newTranslateOffset, newSlideAnchors)\n\n      setClonesLength(newClonesLength)\n      setIndexState(newScrollIndex)\n      setSlideAnchors(newSlideAnchors)\n      setMaxIndex(newMaxIndex)\n      setTranslateOffset({ offset: newTranslateOffset, index: newScrollIndex })\n    }\n  }\n\n  useLayoutEffect(() => {\n    if (resizeObserverRef.current) {\n      resizeObserverRef.current.disconnect()\n    }\n\n    resizeObserverRef.current = new ResizeObserver(() => onResize())\n    resizeObserverRef.current.observe(containerRef.current)\n    slidesRefs.forEach(({ current }) => resizeObserverRef.current.observe(current))\n\n    onResize()\n  }, [slideCount, clonesLength, minDisplayCount, displayCount, gridGap, isInfinite])\n\n  useEffect(() => {\n    setIsScrolling(false)\n\n    if (isInfinite) {\n      onResize()\n    }\n  }, [])\n\n  const onArrowClick = useCallback(\n    (indexOffset, callback, transitionDuration = '500ms') => {\n      if (!areArrowsLocked.current) {\n        areArrowsLocked.current = true\n\n        const boundIndexOffset = Math.min(arrowScrollCount, indexOffset)\n        let newBoundIndex = isInfinite ? index.left + boundIndexOffset : getBoundIndex(index.left + boundIndexOffset)\n\n        if (isInfinite) {\n          const wrappedIndex =\n            newBoundIndex > slideAnchors.length - clonesLength - 1\n              ? newBoundIndex - rawSlides.length - arrowScrollCount\n              : newBoundIndex < clonesLength - 1\n              ? rawSlides.length + arrowScrollCount + newBoundIndex\n              : null\n\n          if (wrappedIndex != null) {\n            slideContainerRef.current.style.transitionDuration = '0ms'\n\n            const wrappedTranslateOffset = -slideAnchors[wrappedIndex].start\n            slideContainerRef.current.style.transform = `translate(${wrappedTranslateOffset}px)`\n\n            translateOffset.current = wrappedTranslateOffset\n            newBoundIndex = getBoundIndex(wrappedIndex + indexOffset)\n          }\n        }\n\n        requestAnimationFrame(() => {\n          slideContainerRef.current.style.transitionDuration = transitionDuration\n\n          if (newBoundIndex !== index.left) {\n            const newTranslateOffset = getTranslateOffset(newBoundIndex)\n            const newScrollIndex = getScrollIndex(newTranslateOffset)\n\n            slideContainerRef.current.addEventListener(\n              'transitionend',\n              () => {\n                slidesRefs[newScrollIndex.left]?.current?.firstChild?.focus()\n                areArrowsLocked.current = false\n              },\n              { once: true },\n            )\n\n            requestAnimationFrame(() => {\n              slideContainerRef.current.style.transform = `translate(${newTranslateOffset}px)`\n            })\n\n            translateOffset.current = newTranslateOffset\n\n            setIndexState(newScrollIndex)\n\n            callback?.(newScrollIndex)\n          } else {\n            areArrowsLocked.current = false\n          }\n        })\n      }\n    },\n    [\n      slideAnchors,\n      isInfinite,\n      index,\n      slideCount,\n      clonesLength,\n      getScrollIndex,\n      getTranslateOffset,\n      setTranslateOffset,\n      getBoundIndex,\n      setIndexState,\n    ],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (areArrowsLocked.current || !isDraggable || isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      isMomentum.current = false\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isDraggable, isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (areArrowsLocked.current || isMomentum.current || !isDraggable || !isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n      touchStartRef.current = touchEndRef.current\n\n      currentDragSpeed.current = delta\n\n      if (delta !== 0) {\n        setTranslateOffset({ offset: translateOffset.current - delta })\n      }\n    },\n    [isDraggable, isScrolling, isDragging, setTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (areArrowsLocked.current || !isDraggable || isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      if (hasDragMomentum) {\n        isMomentum.current = true\n\n        const momentumFunc = (speed) => {\n          currentDragSpeed.current = speed\n          momentumDebounceId.current = requestAnimationFrame(() => {\n            const newTranslateOffset = translateOffset.current - speed\n\n            if (Math.abs(speed) <= 1 || newTranslateOffset >= maxScrollX || newTranslateOffset <= minScrollX) {\n              isMomentum.current = false\n              setIsDragging(false)\n              currentDragSpeed.current = 0\n            } else {\n              setTranslateOffset({ offset: newTranslateOffset })\n              momentumFunc(speed * dragMomentumDecay)\n            }\n          })\n        }\n\n        momentumFunc(\n          currentDragSpeed.current < 0\n            ? Math.max(currentDragSpeed.current, -dragMomentumSpeed)\n            : Math.min(currentDragSpeed.current, dragMomentumSpeed),\n        )\n      } else {\n        setIsDragging(false)\n      }\n    },\n    [\n      hasDragMomentum,\n      dragMomentumSpeed,\n      dragMomentumDecay,\n      minScrollX,\n      maxScrollX,\n      isDraggable,\n      isScrolling,\n      setIsDragging,\n      setTranslateOffset,\n    ],\n  )\n\n  const onScroll = useCallback(\n    (e) => {\n      if (areArrowsLocked.current || !isScrollable || isDragging) {\n        return\n      }\n\n      //TODO handle mouse wheel scrolling correctly\n      // const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        setIsScrolling(false)\n        return\n      }\n\n      if (!isScrolling) {\n        setIsScrolling(true)\n      }\n\n      const newTranslateOffset =\n        translateOffset.current - scrollDirection * Math.min(scrollSpeed, Math.abs(scrollDelta))\n\n      const debounceFunc = () => {\n        setIsScrolling(false)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (!isInfinite && newTranslateOffset >= maxScrollX) {\n        setTranslateOffset({ offset: maxScrollX })\n      } else if (!isInfinite && newTranslateOffset <= minScrollX) {\n        setTranslateOffset({ offset: minScrollX })\n      } else {\n        setTranslateOffset({ offset: newTranslateOffset })\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      isInfinite,\n      isScrollable,\n      scrollSpeed,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      isDragging,\n      setIsScrolling,\n      setTranslateOffset,\n    ],\n  )\n\n  useEffect(() => {\n    //remove clones from tab index\n    Array.from(slideContainerRef.current.children).forEach((child, index) => {\n      if (index < minTabIndex || index > maxTabIndex) {\n        child.querySelectorAll('*').forEach((node) => {\n          node.tabIndex = -1\n        })\n      }\n    })\n  }, [minTabIndex, maxTabIndex, slideContainerRef.current])\n\n  const onSlideFocus = useCallback(\n    (i) => (e) => {\n      const isFirstFocus = !e.currentTarget.contains(e.relatedTarget)\n\n      if (isFirstFocus && i >= minTabIndex && i <= maxTabIndex) {\n        //prevent auto-scroll when tabbing\n        slidesOuterContainerRef.current.scrollLeft = 0\n\n        const isEnabled = !areArrowsLocked.current && !(isDraggable && isDragging) && !(isScrollable && isScrolling)\n\n        if (isEnabled && (i < index.left || i > index.right)) {\n          onArrowClick((i < index.left ? -1 : 1) * (isInfinite ? 1 : activeIndexes.length), () => {\n            //failsafe to prevent forced scrolling when focusing elements\n            slidesOuterContainerRef.current.scrollLeft = 0\n\n            slideContainerRef.current.addEventListener(\n              'transitionend',\n              () => {\n                slidesRefs[i]?.current?.firstChild?.focus()\n              },\n              { once: true },\n            )\n          })\n        }\n      }\n    },\n    [index, index.left, index.right, isInfinite, isDragging, isDraggable, isScrollable, isScrolling, onArrowClick],\n  )\n\n  const onSlideKeyDown = useCallback(\n    (e) => {\n      if (areArrowsLocked.current || (isDraggable && isDragging) || (isScrollable && isScrolling)) {\n        e.preventDefault()\n        e.stopPropagation()\n      }\n    },\n    [isDraggable, isDragging, isScrollable, isScrolling],\n  )\n\n  const onMouseEnter = useCallback(() => {\n    setIsHovering(true)\n  }, [setIsHovering])\n\n  const onMouseLeave = useCallback(() => {\n    setIsHovering(false)\n  }, [setIsHovering])\n\n  useEffect(() => {\n    if (!areArrowsLocked.current && !(isDraggable && isDragging) && !(isScrollable && isScrolling)) {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      const newTranslateOffset = getTranslateOffset(index.left)\n      setTranslateOffset({ offset: newTranslateOffset })\n\n      //focus correct child after scrolling\n      if (translateOffset.current !== newTranslateOffset) {\n        slidesRefs[index.left]?.current?.firstChild?.focus()\n      }\n\n      touchStartRef.current = 0\n      touchEndRef.current = 0\n    }\n  }, [isDragging, isDraggable, isScrolling, isScrollable])\n\n  const containerCss = useMemo(\n    () =>\n      ContainerCss({\n        minDisplayCount,\n        displayCount,\n        slideAnchors,\n      }),\n    [slideAnchors, slideAnchors?.length, minDisplayCount, displayCount],\n  )\n\n  return (\n    <div\n      className={styles.container}\n      style={{\n        ...containerCss,\n        ...style,\n      }}\n      ref={containerRef}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      <div className={styles.slidesAndArrowsContainer} onMouseLeave={onTouchEnd}>\n        {RenderArrows ? (\n          <RenderArrows\n            startIndex={index.left - clonesLength}\n            endIndex={index.right - clonesLength}\n            activeIndexes={activeIndexes}\n            isLeft={true}\n            isRight={false}\n            isHidden={!isHovering || isScrolling || isDragging || !showLeftArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowLeftProps}\n            scrollCount={arrowScrollCount}\n          />\n        ) : null}\n        <div ref={slidesOuterContainerRef} className={styles.slidesOuterContainer}>\n          <ul\n            ref={slideContainerRef}\n            className={styles.slidesContainer}\n            style={{\n              display: 'flex',\n              flexDirection: 'row',\n              listStyleType: 'none',\n              margin: '0px',\n              padding: '0px',\n              ...slideContainerStyle,\n            }}\n            onTouchStart={onTouchStart}\n            onTouchMove={onTouchMove}\n            onTouchEnd={onTouchEnd}\n            onTouchCancel={onTouchEnd}\n            onMouseDown={onTouchStart}\n            onMouseMove={onTouchMove}\n            onMouseUp={onTouchEnd}\n            onWheel={onScroll}\n          >\n            {slides.map((slide, i) => (\n              <li\n                style={{\n                  paddingRight: `${!isInfinite && i === slides.length - 1 ? 0 : gridGap}px`,\n                  ...slideStyle,\n                }}\n                ref={slidesRefs[i]}\n                key={i}\n                onFocus={onSlideFocus(i)}\n                onKeyDown={onSlideKeyDown}\n              >\n                {slide}\n              </li>\n            ))}\n          </ul>\n        </div>\n        {RenderArrows ? (\n          <RenderArrows\n            startIndex={index.left - clonesLength}\n            endIndex={index.right - clonesLength}\n            activeIndexes={activeIndexes}\n            isLeft={false}\n            isRight={true}\n            isHidden={!isHovering || isScrolling || isDragging || !showRightArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowRightProps}\n            scrollCount={arrowScrollCount}\n          />\n        ) : null}\n      </div>\n      {RenderIndexes ? (\n        <RenderIndexes\n          startIndex={index.left - clonesLength}\n          endIndex={index.right - clonesLength}\n          activeIndexes={activeIndexes}\n          indexesPerRow={indexesPerRow || rawSlides.length}\n          slideAnchors={coreSlideAnchors}\n          scrollBy={onArrowClick}\n          indexContainerProps={indexContainerProps}\n          indexProps={indexProps}\n        />\n      ) : null}\n    </div>\n  )\n}\n","import React, { useCallback, useMemo } from 'react'\nimport styles from './Arrows.module.css'\n\nexport const Arrows = ({ isLeft, isHidden, scrollBy, scrollCount, arrowProps, arrowIconProps }) => {\n  const arrowClassName = useMemo(\n    () =>\n      `${styles.arrow} ${isLeft ? styles.leftArrow : styles.rightArrow} ${isHidden ? styles.isArrowHidden : ''} ${\n        arrowProps?.className || ''\n      }`,\n    [arrowProps?.className, isLeft, isHidden],\n  )\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [arrowProps?.onClick, scrollBy, isLeft],\n  )\n\n  const iconClassName = useMemo(\n    () =>\n      `${styles.arrowIcon} ${isLeft ? styles.leftArrowIcon : styles.rightArrowIcon} ${arrowIconProps?.className || ''}`,\n    [arrowIconProps?.className, isLeft],\n  )\n\n  return (\n    <button\n      {...arrowProps}\n      tabIndex={-1} //no focus by default for ADA\n      className={arrowClassName}\n      onClick={onClick(arrowProps?.onClick, isLeft ? -scrollCount : scrollCount)}\n    >\n      <span {...arrowIconProps} className={iconClassName} />\n    </button>\n  )\n}\n","import React, { useCallback, useMemo, useRef } from 'react'\nimport styles from './Indexes.module.css'\n\nexport const Indexes = ({\n  activeIndexes,\n  startIndex,\n  indexesPerRow,\n  slideAnchors,\n  scrollBy,\n  indexContainerProps,\n  indexProps,\n}) => {\n  const containerRef = useRef()\n  const gap = 5\n  const borderWidth = 2\n  const width = useMemo(() => `calc((100% - ${(indexesPerRow - 1) * gap}px) / ${indexesPerRow})`, [indexesPerRow])\n\n  const containerClassName = useMemo(\n    () => `${styles.indexContainer} ${indexContainerProps?.className || ''}`,\n    [indexContainerProps?.className],\n  )\n\n  const iconClassName = useMemo(() => `${styles.index} ${indexProps?.className || ''}`, [indexProps?.className])\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [scrollBy],\n  )\n\n  return (\n    <div\n      {...indexContainerProps}\n      ref={containerRef}\n      className={containerClassName}\n      style={{ gap: `${gap}px`, ...indexContainerProps?.style }}\n    >\n      {slideAnchors?.map((_, i) => (\n        <button\n          tabIndex={-1} //disabled for ADA\n          key={i}\n          {...indexProps}\n          className={iconClassName}\n          style={{\n            backgroundColor: activeIndexes.includes(i) ? 'black' : 'transparent',\n            width,\n            borderWidth: `${borderWidth}px`,\n            ...indexProps?.style,\n          }}\n          onClick={onClick(indexProps?.onClick, i - startIndex)}\n        />\n      ))}\n    </div>\n  )\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","getClientXOffset","e","touches","clientX","calcMinWidth","slideAnchors","count","length","reduce","acc","start","i","groupWidth","Math","min","end","Carousel","isInfinite","startIndex","isScrollable","isDraggable","hasDragMomentum","dragMomentumSpeed","dragMomentumDecay","minDisplayCount","displayCount","gridGap","arrows","RenderArrows","arrowLeftProps","arrowRightProps","scrollSpeed","scrollCount","shouldScrollByDisplayCount","indexesPerRow","indexes","RenderIndexes","indexContainerProps","indexProps","slideContainerStyle","slideStyle","children","isHovering","setIsHovering","useState","momentumDebounceId","useRef","transitionDebounceId","areArrowsLocked","currentDragSpeed","resizeObserverRef","rawSlides","React","Children","toArray","clonesLength","setClonesLength","slides","useMemo","slice","slideCount","slidesRefs","Array","fill","map","_","createRef","setSlideAnchors","coreSlideAnchors","minTabIndex","index","maxTabIndex","containerRef","slideContainerRef","slidesOuterContainerRef","getTranslateOffset","useCallback","newIndex","newSlideAnchors","setIndexState","left","right","activeIndexes","arrowScrollCount","maxIndex","setMaxIndex","isDragging","setIsDragging","isScrolling","setIsScrolling","isMomentum","translateOffset","touchStartRef","touchEndRef","scrollDebounceId","minScrollX","showLeftArrow","showRightArrow","getBoundIndex","newMaxIndex","max","getScrollIndex","newTranslateOffset","currentOffset","width","current","clientWidth","setTranslateOffset","offset","newClonesLength","requestAnimationFrame","boundOffset","rightAnchor","leftAnchor","cancelAnimationFrame","transitionDuration","transform","onResize","slideRefs","push","calculateAnchors","containerWidth","leftCount","rightCount","reduceRight","calcClonesLength","lastEnd","findIndex","newLeftIndex","newScrollIndex","useLayoutEffect","disconnect","ResizeObserver","observe","forEach","useEffect","onArrowClick","indexOffset","callback","boundIndexOffset","newBoundIndex","wrappedIndex","wrappedTranslateOffset","addEventListener","focus","once","onTouchStart","xOffset","onTouchMove","stopPropagation","delta","onTouchEnd","momentumFunc","speed","abs","onScroll","scrollDelta","deltaX","scrollDirection","sign","debounceFunc","clearTimeout","setTimeout","from","child","querySelectorAll","node","tabIndex","onSlideFocus","currentTarget","contains","relatedTarget","scrollLeft","onSlideKeyDown","preventDefault","onMouseEnter","onMouseLeave","containerCss","minWidth","ContainerCss","className","styles","endIndex","isLeft","isRight","isHidden","scrollBy","arrowProps","display","flexDirection","listStyleType","margin","padding","onTouchCancel","onMouseDown","onMouseMove","onMouseUp","onWheel","slide","paddingRight","key","onFocus","onKeyDown","Arrows","arrowIconProps","arrowClassName","onClick","iconClassName","Indexes","containerClassName","gap","_extends","backgroundColor","includes","borderWidth"],"mappings":"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"}