{"version":3,"file":"index.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/components/Carousel.jsx"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","import React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\nimport styles from './Carousel.module.css'\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nconst calculateAnchors = (slideRefs = [], gridGap = 0) =>\n  slideRefs.reduce((acc, ref, i) => {\n    if (ref?.current) {\n      const width = ref.current.clientWidth\n      const start = i === 0 ? 0 : acc[i - 1].end + gridGap\n      const end = start + width\n      acc.push({ start, end, width })\n    }\n    return acc\n  }, [])\n\nconst calcMinWidth = (slideAnchors, count) =>\n  slideAnchors?.length && count && count > 0\n    ? slideAnchors.reduce((acc, { start }, i) => {\n        const groupWidth = slideAnchors[Math.min(i + count - 1, slideAnchors.length - 1)].end - start\n\n        return groupWidth > acc ? groupWidth : acc\n      }, 0)\n    : 0\n\nconst ContainerCss = ({ displayCount, minDisplayCount, slideAnchors }) => {\n  const minWidth = calcMinWidth(slideAnchors, minDisplayCount)\n  const width = calcMinWidth(slideAnchors, displayCount)\n\n  return {\n    minWidth: minWidth ? `${minWidth}px` : 'auto',\n    width: width ? `${width}px` : '100%',\n  }\n}\n\nconst SlidesContainerCss = ({ gridGap, isScrolling, isDragging }) => ({\n  gap: `${gridGap}px`,\n  transition: `transform ${isScrolling || isDragging ? '0ms' : '500ms'}`,\n})\n\nconst Arrow = ({ isLeft, isHidden, scrollBy }) => {\n  const onClick = useCallback((scrollCount) => (e) => {\n    e.preventDefault()\n    e.stopPropagation()\n    scrollBy(scrollCount)\n  })\n\n  return (\n    <button\n      className={`${styles.arrow} ${isLeft ? styles.leftArrow : styles.rightArrow} ${\n        isHidden ? styles.isArrowHidden : ''\n      }`}\n      onClick={onClick(isLeft ? -1 : 1)}\n    >\n      <span className={`${styles.arrowIcon} ${isLeft ? styles.leftArrowIcon : styles.rightArrowIcon}`} />\n    </button>\n  )\n}\n\nexport const Carousel = ({\n  startIndex = 0,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  showArrows = true,\n  renderArrows: RenderArrows = Arrow,\n  scrollSpeed = 75,\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const resizeObserverRef = useRef()\n  const slides = React.Children.toArray(children) || []\n  const slideCount = slides.length\n  const slidesRefs = useMemo(\n    () =>\n      Array(slideCount)\n        .fill(null)\n        .map((_, i) => slidesRefs?.[i] || React.createRef()),\n    [slideCount],\n  )\n  const [slideAnchors, setSlideAnchors] = useState([])\n  const containerRef = useRef(null)\n  const slideContainerRef = useRef(null)\n  const getTranslateOffset = useCallback(\n    (newIndex, newSlideAnchors = slideAnchors) => {\n      const start = newSlideAnchors?.[newIndex]?.start\n      return start != null ? -1 * start : 0\n    },\n\n    [slideAnchors],\n  )\n  const indexRef = useRef(startIndex)\n  const [index, setIndexState] = useState(startIndex)\n  const setIndex = useCallback(\n    (newIndex) => {\n      setIndexState(newIndex)\n      indexRef.current = newIndex\n    },\n    [setIndexState],\n  )\n  const [maxIndex, setMaxIndex] = useState(slideCount)\n  const [isDragging, setIsDragging] = useState(false)\n  const [isScrolling, setIsScrolling] = useState(false)\n  const translateOffset = useRef(getTranslateOffset(index))\n  const touchStartRef = useRef(0)\n  const touchEndRef = useRef(0)\n  const scrollDebounceId = useRef()\n  const maxScrollX = 0\n  const minScrollX = useMemo(() => {\n    const start = slideAnchors?.[maxIndex]?.start\n\n    return start != null ? -1 * start : 0\n  }, [slideAnchors, slideCount, maxIndex])\n  const showLeftArrow = index !== 0\n  const showRightArrow =\n    translateOffset.current != null && containerRef.current != null && slideAnchors?.[slideCount - 1] != null\n      ? -1 * translateOffset.current + containerRef.current.clientWidth < slideAnchors?.[slideCount - 1].end\n      : true\n\n  const getBoundIndex = useCallback(\n    (newIndex, newMaxIndex = maxIndex) => Math.max(0, Math.min(newMaxIndex, newIndex)),\n    [maxIndex],\n  )\n\n  const setTranslateOffset = useCallback((offset) => {\n    translateOffset.current = offset\n    requestAnimationFrame(() => {\n      if (slideContainerRef.current) {\n        slideContainerRef.current.style.transform = `translate(${offset}px)`\n      }\n    })\n  }, [])\n\n  const onResize = () => {\n    const newSlideAnchors = calculateAnchors(slidesRefs, gridGap)\n    const containerWidth = containerRef.current.clientWidth\n    const lastEnd = newSlideAnchors[newSlideAnchors.length - 1].end\n    const newMaxIndex = getBoundIndex(\n      newSlideAnchors.findIndex(({ start }) => start + containerWidth >= lastEnd),\n      newSlideAnchors.length - 1,\n    )\n    const newIndex = getBoundIndex(indexRef.current, newMaxIndex)\n    const newTranslateOffset = getTranslateOffset(newIndex, newSlideAnchors)\n\n    setIndex(newIndex)\n    setSlideAnchors(newSlideAnchors)\n    setMaxIndex(newMaxIndex)\n    setTranslateOffset(newTranslateOffset)\n  }\n\n  const getNewScrollState = useCallback(\n    (newIndex) => {\n      const newBoundIndex = getBoundIndex(newIndex)\n\n      const newBoundScrollDelta = getTranslateOffset(newBoundIndex)\n\n      return {\n        index: newBoundIndex,\n        translateOffset: newBoundScrollDelta,\n      }\n    },\n    [slideCount, getTranslateOffset, getBoundIndex],\n  )\n\n  useLayoutEffect(() => {\n    if (resizeObserverRef.current) {\n      resizeObserverRef.current.disconnect()\n    }\n\n    resizeObserverRef.current = new ResizeObserver(onResize)\n    slidesRefs.forEach(({ current }) => resizeObserverRef.current.observe(current))\n\n    onResize()\n  }, [slideCount, minDisplayCount, displayCount, gridGap])\n\n  useEffect(() => {\n    window.addEventListener('resize', onResize)\n\n    return () => {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect()\n      }\n\n      window.removeEventListener('resize', onResize)\n    }\n  }, [])\n\n  const onArrowClick = useCallback(\n    (indexOffset) => {\n      const newIndex = index + indexOffset\n      const newBoundIndex = getBoundIndex(newIndex)\n\n      setIndex(newBoundIndex)\n      setTranslateOffset(getTranslateOffset(newBoundIndex))\n    },\n    [index, slideCount, getTranslateOffset, setIndex, setTranslateOffset, getBoundIndex],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (!isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n      touchStartRef.current = touchEndRef.current\n\n      if (delta !== 0) {\n        setTranslateOffset(translateOffset.current - delta)\n      }\n    },\n    [isScrolling, isDragging, index, setTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      const currentOffset = -1 * translateOffset.current\n\n      const newIndex = slideAnchors.reduce((acc, { start, width }, i) => {\n        return currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc\n      }, 0)\n\n      const newBoundIndex = getBoundIndex(newIndex)\n\n      setIndex(newBoundIndex)\n      setTranslateOffset(getTranslateOffset(newBoundIndex))\n\n      touchStartRef.current = 0\n      touchEndRef.current = 0\n\n      setIsDragging(false)\n    },\n    [isScrolling, slideAnchors, setTranslateOffset, getTranslateOffset, setIndex, getBoundIndex, setIsDragging],\n  )\n\n  const onScroll = useCallback(\n    (e) => {\n      if (isDragging) {\n        return\n      }\n\n      const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = isWheel ? -1 * e.deltaY : e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        return\n      }\n\n      if (!isScrolling && !isWheel) {\n        setIsScrolling(true)\n      }\n\n      const newScrollDelta = translateOffset.current - scrollDirection * Math.min(scrollSpeed, Math.abs(scrollDelta))\n\n      const debounceFunc = () => {\n        setIsScrolling(false)\n\n        const currentOffset = -1 * newScrollDelta\n\n        const newIndex = slideAnchors.reduce((acc, { start, width }, i) => {\n          return currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc\n        }, 0)\n\n        const newBoundIndex = getBoundIndex(newIndex)\n\n        setIndex(newBoundIndex)\n        setTranslateOffset(getTranslateOffset(newBoundIndex))\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (newScrollDelta >= maxScrollX) {\n        setTranslateOffset(maxScrollX)\n        debounceFunc()\n      } else if (newScrollDelta <= minScrollX) {\n        setTranslateOffset(minScrollX)\n        debounceFunc()\n      } else {\n        setTranslateOffset(newScrollDelta)\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      slideAnchors,\n      scrollSpeed,\n      gridGap,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      isDragging,\n      setIsScrolling,\n      setIndex,\n      setTranslateOffset,\n      getNewScrollState,\n    ],\n  )\n\n  const slideContainerCss = useMemo(\n    () =>\n      SlidesContainerCss({\n        gridGap,\n        isScrolling,\n        isDragging,\n      }),\n    [gridGap, isScrolling, isDragging],\n  )\n\n  return (\n    <div\n      className={styles.container}\n      style={{\n        ...ContainerCss({\n          minDisplayCount,\n          displayCount,\n          slideAnchors,\n        }),\n        ...style,\n      }}\n      ref={containerRef}\n    >\n      {showArrows && (\n        <RenderArrows\n          isLeft={true}\n          isRight={false}\n          isHidden={isScrolling || isDragging || !showLeftArrow}\n          scrollBy={onArrowClick}\n        />\n      )}\n      <div\n        ref={slideContainerRef}\n        className={styles.slideContainer}\n        style={{\n          ...slideContainerCss,\n          ...slideContainerStyle,\n        }}\n        onTouchStart={onTouchStart}\n        onTouchMove={onTouchMove}\n        onTouchEnd={onTouchEnd}\n        onTouchCancel={onTouchEnd}\n        onMouseDown={onTouchStart}\n        onMouseMove={onTouchMove}\n        onMouseUp={onTouchEnd}\n        onMouseLeave={onTouchEnd}\n        onWheel={onScroll}\n      >\n        {slides.map((slide, i) => (\n          <div style={slideStyle} ref={slidesRefs[i]} key={i}>\n            {slide}\n          </div>\n        ))}\n      </div>\n      {showArrows && (\n        <RenderArrows\n          isLeft={false}\n          isRight={true}\n          isHidden={isScrolling || isDragging || !showRightArrow}\n          scrollBy={onArrowClick}\n        />\n      )}\n    </div>\n  )\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","getClientXOffset","e","touches","clientX","calcMinWidth","slideAnchors","count","length","reduce","acc","start","i","groupWidth","Math","min","end","ContainerCss","displayCount","minDisplayCount","minWidth","width","Arrow","isLeft","isHidden","scrollBy","onClick","useCallback","scrollCount","preventDefault","stopPropagation","React","className","styles","startIndex","gridGap","showArrows","renderArrows","RenderArrows","scrollSpeed","slideContainerStyle","slideStyle","children","resizeObserverRef","useRef","slides","Children","toArray","slideCount","slidesRefs","useMemo","Array","fill","map","_","createRef","setSlideAnchors","useState","containerRef","slideContainerRef","getTranslateOffset","newIndex","newSlideAnchors","indexRef","index","setIndexState","setIndex","current","maxIndex","setMaxIndex","isDragging","setIsDragging","isScrolling","setIsScrolling","translateOffset","touchStartRef","touchEndRef","scrollDebounceId","minScrollX","showLeftArrow","showRightArrow","clientWidth","getBoundIndex","newMaxIndex","max","setTranslateOffset","offset","requestAnimationFrame","transform","onResize","slideRefs","push","calculateAnchors","containerWidth","lastEnd","findIndex","newTranslateOffset","getNewScrollState","newBoundIndex","useLayoutEffect","disconnect","ResizeObserver","forEach","observe","useEffect","window","addEventListener","removeEventListener","onArrowClick","indexOffset","onTouchStart","xOffset","onTouchMove","delta","onTouchEnd","currentOffset","onScroll","isWheel","deltaX","abs","deltaY","scrollDelta","scrollDirection","sign","newScrollDelta","debounceFunc","clearTimeout","setTimeout","slideContainerCss","gap","transition","SlidesContainerCss","isRight","onTouchCancel","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onWheel","slide","key"],"mappings":"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"}