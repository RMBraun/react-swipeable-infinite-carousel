{"version":3,"file":"index.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/components/Carousel.jsx"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/* eslint-disable react/prop-types */\nimport React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\nimport styles from './Carousel.module.css'\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nconst calculateAnchors = (slideRefs = []) =>\n  slideRefs.reduce((acc, ref, i) => {\n    if (ref?.current) {\n      const width = ref.current.clientWidth\n      const start = i === 0 ? 0 : acc[i - 1].end\n      const end = start + width\n      acc.push({ start, end, width })\n    }\n    return acc\n  }, [])\n\nconst calcMinWidth = (slideAnchors, count) =>\n  slideAnchors?.length && count && count > 0\n    ? slideAnchors.reduce((acc, { start }, i) => {\n        const groupWidth = slideAnchors[Math.min(i + count - 1, slideAnchors.length - 1)].end - start\n\n        return groupWidth > acc ? groupWidth : acc\n      }, 0)\n    : 0\n\nconst ContainerCss = ({ displayCount, minDisplayCount, slideAnchors }) => {\n  const minWidth = calcMinWidth(slideAnchors, minDisplayCount)\n  const width = calcMinWidth(slideAnchors, displayCount)\n\n  return {\n    minWidth: minWidth ? `${minWidth}px` : 'auto',\n    width: width ? `${width}px` : '100%',\n  }\n}\n\nconst SlidesContainerCss = ({ isScrolling, isDragging }) => ({\n  transition: `transform ${isScrolling || isDragging ? '0ms' : '500ms'}`,\n})\n\n// eslint-disable-next-line no-unused-vars\nconst Arrow = ({ isLeft, isRight, isHidden, scrollBy, arrowProps, arrowIconProps }) => {\n  const arrowClassName = useMemo(\n    () =>\n      `${styles.arrow} ${isLeft ? styles.leftArrow : styles.rightArrow} ${isHidden ? styles.isArrowHidden : ''} ${\n        arrowProps?.className || ''\n      }`,\n    [arrowProps?.className, isLeft, isHidden],\n  )\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [arrowProps?.onClick, scrollBy, isLeft],\n  )\n\n  const iconClassName = useMemo(\n    () =>\n      `${styles.arrowIcon} ${isLeft ? styles.leftArrowIcon : styles.rightArrowIcon} ${arrowIconProps?.className || ''}`,\n    [arrowIconProps?.className, isLeft],\n  )\n\n  return (\n    <button {...arrowProps} className={arrowClassName} onClick={onClick(arrowProps?.onClick, isLeft ? -1 : 1)}>\n      <span {...arrowIconProps} className={iconClassName} />\n    </button>\n  )\n}\n\n// eslint-disable-next-line no-unused-vars\nconst Indexes = ({ startIndex, endIndex, indexesPerRow, slideAnchors, scrollBy, indexContainerProps, indexProps }) => {\n  const containerRef = useRef()\n  const gap = 5\n  const borderWidth = 2\n  const width = useMemo(() => `calc((100% - ${(indexesPerRow - 1) * gap}px) / ${indexesPerRow})`, [indexesPerRow])\n\n  const containerClassName = useMemo(\n    () => `${styles.indexContainer} ${indexContainerProps?.className || ''}`,\n    [indexContainerProps?.className],\n  )\n\n  const iconClassName = useMemo(() => `${styles.index} ${indexProps?.className || ''}`, [indexProps?.className])\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [indexProps?.onClick, scrollBy, startIndex],\n  )\n\n  return (\n    <div\n      {...indexContainerProps}\n      ref={containerRef}\n      className={containerClassName}\n      style={{ gap: `${gap}px`, ...indexContainerProps?.style }}\n    >\n      {slideAnchors?.map((_, i) => (\n        <button\n          key={i}\n          {...indexProps}\n          className={iconClassName}\n          style={{\n            backgroundColor: i >= startIndex && i <= endIndex ? 'black' : 'transparent',\n            width,\n            borderWidth: `${borderWidth}px`,\n            ...indexProps?.style,\n          }}\n          onClick={onClick(indexProps?.onClick, i - startIndex)}\n        />\n      ))}\n    </div>\n  )\n}\n\nexport const Carousel = ({\n  startIndex = 0,\n  isScrollable = true,\n  isDraggable = true,\n  hasDragMomentum = true,\n  dragMomentumSpeed = 25,\n  dragMomentumDecay = 0.98,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  showArrows = true,\n  renderArrows: RenderArrows = Arrow,\n  arrowLeftProps = {},\n  arrowRightProps = {},\n  scrollSpeed = 75,\n  showIndexes = true,\n  indexesPerRow = 0,\n  renderIndexes: RenderIndexes = Indexes,\n  indexContainerProps = {},\n  indexProps = {},\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const momentumTimeoutId = useRef()\n  const currentDragSpeed = useRef(0)\n  const resizeObserverRef = useRef()\n  const slides = React.Children.toArray(children) || []\n  const slideCount = slides.length\n  const slidesRefs = useMemo(\n    () =>\n      Array(slideCount)\n        .fill(null)\n        .map((_, i) => slidesRefs?.[i] || React.createRef()),\n    [slideCount],\n  )\n  const [slideAnchors, setSlideAnchors] = useState([])\n  const containerRef = useRef(null)\n  const slideContainerRef = useRef(null)\n  const getTranslateOffset = useCallback(\n    (newIndex, newSlideAnchors = slideAnchors) => {\n      const start = newSlideAnchors?.[newIndex]?.start\n      return start != null ? -1 * start : 0\n    },\n\n    [slideAnchors],\n  )\n  const [index, setIndexState] = useState({ left: startIndex, right: startIndex })\n  const indexRef = useRef(index)\n  const setIndex = useCallback(\n    (newIndex) => {\n      indexRef.current = newIndex\n      setIndexState(newIndex)\n    },\n    [setIndexState],\n  )\n  const [maxIndex, setMaxIndex] = useState(slideCount)\n  const [isDragging, setIsDragging] = useState(false)\n  const [isScrolling, setIsScrolling] = useState(false)\n  const isMomentum = useRef(false)\n\n  const translateOffset = useRef(() => getTranslateOffset(index.left))\n  const touchStartRef = useRef(0)\n  const touchEndRef = useRef(0)\n  const scrollDebounceId = useRef()\n  const maxScrollX = 0\n  const minScrollX = useMemo(() => {\n    const start = slideAnchors?.[maxIndex]?.start\n\n    return start != null ? -1 * start : 0\n  }, [slideAnchors, slideCount, maxIndex])\n  const showLeftArrow = index.left !== 0\n  const showRightArrow =\n    translateOffset.current != null && containerRef.current != null && slideAnchors?.[slideCount - 1] != null\n      ? -1 * translateOffset.current + containerRef.current.clientWidth < slideAnchors?.[slideCount - 1].end\n      : true\n\n  const getBoundIndex = useCallback(\n    (newIndex, newMaxIndex = maxIndex) => Math.max(0, Math.min(newMaxIndex, newIndex)),\n    [maxIndex],\n  )\n\n  const getScrollIndex = useCallback(\n    (newTranslateOffset, newSlideAnchors = slideAnchors) => {\n      const currentOffset = -1 * newTranslateOffset\n\n      const newIndex = newSlideAnchors.reduce(\n        (acc, { start, end, width }, i) => {\n          acc.left = currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc.left\n          acc.right =\n            containerRef.current != null\n              ? currentOffset + containerRef.current.clientWidth >= end\n                ? i\n                : acc.right\n              : slideCount - 1\n\n          return acc\n        },\n        {\n          left: 0,\n          right: 0,\n        },\n      )\n\n      return {\n        left: getBoundIndex(newIndex.left),\n        right: Math.max(Math.min(slideCount - 1, newIndex.right), newIndex.left),\n      }\n    },\n    [slideCount, slideAnchors, getBoundIndex],\n  )\n\n  const setTranslateOffset = useCallback((offset) => {\n    translateOffset.current = offset\n    requestAnimationFrame(() => {\n      if (slideContainerRef.current) {\n        slideContainerRef.current.style.transform = `translate(${offset}px)`\n      }\n    })\n  }, [])\n\n  const onResize = () => {\n    const newSlideAnchors = calculateAnchors(slidesRefs)\n    if (newSlideAnchors?.length) {\n      const containerWidth = slideContainerRef.current.clientWidth\n      const lastEnd = newSlideAnchors[newSlideAnchors.length - 1].end\n      const newMaxIndex = getBoundIndex(\n        newSlideAnchors.findIndex(({ start }) => start + containerWidth >= lastEnd),\n        newSlideAnchors.length - 1,\n      )\n      const newLeftIndex = getBoundIndex(indexRef.current.left, newMaxIndex)\n      const newTranslateOffset = getTranslateOffset(newLeftIndex, newSlideAnchors)\n      const newScrollIndex = getScrollIndex(newTranslateOffset, newSlideAnchors)\n\n      setIndex(newScrollIndex)\n      setSlideAnchors(newSlideAnchors)\n      setMaxIndex(newMaxIndex)\n      setTranslateOffset(newTranslateOffset)\n    }\n  }\n\n  useLayoutEffect(() => {\n    if (resizeObserverRef.current) {\n      resizeObserverRef.current.disconnect()\n    }\n\n    resizeObserverRef.current = new ResizeObserver(onResize)\n    slidesRefs.forEach(({ current }) => resizeObserverRef.current.observe(current))\n\n    onResize()\n  }, [slideCount, minDisplayCount, displayCount, gridGap])\n\n  useEffect(() => {\n    window.addEventListener('resize', onResize)\n\n    return () => {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.disconnect()\n      }\n\n      window.removeEventListener('resize', onResize)\n    }\n  }, [])\n\n  const onArrowClick = useCallback(\n    (indexOffset) => {\n      const newBoundIndex = getBoundIndex(index.left + indexOffset)\n      const newTranslateOffset = getTranslateOffset(newBoundIndex)\n      const newScrollIndex = getScrollIndex(newTranslateOffset)\n\n      setIndex(newScrollIndex)\n      setTranslateOffset(newTranslateOffset)\n    },\n    [index, slideCount, getTranslateOffset, setIndex, setTranslateOffset, getBoundIndex],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (momentumTimeoutId.current) {\n        cancelAnimationFrame(momentumTimeoutId.current)\n      }\n\n      if (!isDraggable || isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      isMomentum.current = false\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isDraggable, isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (isMomentum.current || !isDraggable || !isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n      touchStartRef.current = touchEndRef.current\n\n      currentDragSpeed.current = delta\n\n      if (delta !== 0) {\n        const newTranslateOffset = translateOffset.current - delta\n        const newScrollIndex = getScrollIndex(newTranslateOffset)\n\n        setIndex(newScrollIndex)\n        setTranslateOffset(newTranslateOffset)\n      }\n    },\n    [isDraggable, slideAnchors, isScrolling, isDragging, index, setTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (momentumTimeoutId.current) {\n        cancelAnimationFrame(momentumTimeoutId.current)\n      }\n\n      if (!isDraggable || isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      if (hasDragMomentum) {\n        isMomentum.current = true\n\n        const momentumFunc = (speed) => {\n          momentumTimeoutId.current = requestAnimationFrame(() => {\n            const newTranslateOffset = translateOffset.current - speed\n\n            if (Math.abs(speed) <= 1 || newTranslateOffset >= maxScrollX || newTranslateOffset <= minScrollX) {\n              isMomentum.current = false\n              setIsDragging(false)\n            } else {\n              const newScrollIndex = getScrollIndex(newTranslateOffset)\n\n              setIndex(newScrollIndex)\n              setTranslateOffset(newTranslateOffset)\n\n              momentumFunc(speed * dragMomentumDecay)\n            }\n          })\n        }\n\n        momentumFunc(\n          currentDragSpeed.current < 0\n            ? Math.max(currentDragSpeed.current, -dragMomentumSpeed)\n            : Math.min(currentDragSpeed.current, dragMomentumSpeed),\n        )\n        currentDragSpeed.current = 0\n      } else {\n        setIsDragging(false)\n      }\n    },\n    [\n      hasDragMomentum,\n      dragMomentumSpeed,\n      dragMomentumDecay,\n      minScrollX,\n      maxScrollX,\n      isDraggable,\n      isScrolling,\n      setIsDragging,\n    ],\n  )\n\n  useEffect(() => {\n    if (!isDragging || !isDraggable) {\n      if (momentumTimeoutId.current) {\n        cancelAnimationFrame(momentumTimeoutId.current)\n      }\n\n      const currentOffset = -1 * translateOffset.current\n\n      const newIndex = slideAnchors.reduce((acc, { start, width }, i) => {\n        return currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc\n      }, 0)\n\n      const newBoundIndex = getBoundIndex(newIndex)\n      const newTranslateOffset = getTranslateOffset(newBoundIndex)\n      const newScrollIndex = getScrollIndex(newTranslateOffset)\n\n      setIndex(newScrollIndex)\n      setTranslateOffset(newTranslateOffset)\n\n      touchStartRef.current = 0\n      touchEndRef.current = 0\n    }\n  }, [isDragging, isDraggable])\n\n  const onScroll = useCallback(\n    (e) => {\n      if (!isScrollable || isDragging) {\n        return\n      }\n\n      const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = isWheel ? -1 * e.deltaY : e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        return\n      }\n\n      if (!isScrolling) {\n        setIsScrolling(true)\n      }\n\n      const newTranslateOffset =\n        translateOffset.current - scrollDirection * Math.min(scrollSpeed, Math.abs(scrollDelta))\n\n      const newBoundIndex = getScrollIndex(newTranslateOffset)\n\n      if (index.left !== newBoundIndex.left || index.right !== newBoundIndex.right) {\n        setIndex(newBoundIndex)\n      }\n\n      const debounceFunc = () => {\n        if (isScrolling) {\n          setIsScrolling(false)\n          const finalTranslateOffset = getTranslateOffset(newBoundIndex.left)\n          const finalBoundIndex = getScrollIndex(finalTranslateOffset)\n          setIndex(finalBoundIndex)\n          setTranslateOffset(finalTranslateOffset)\n        }\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (newTranslateOffset >= maxScrollX) {\n        setTranslateOffset(maxScrollX)\n        debounceFunc()\n      } else if (newTranslateOffset <= minScrollX) {\n        setTranslateOffset(minScrollX)\n        debounceFunc()\n      } else {\n        setTranslateOffset(newTranslateOffset)\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      isScrollable,\n      index,\n      slideAnchors,\n      scrollSpeed,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      isDragging,\n      setIsScrolling,\n      setIndex,\n      setTranslateOffset,\n    ],\n  )\n\n  const slideContainerCss = useMemo(\n    () =>\n      SlidesContainerCss({\n        isScrolling,\n        isDragging,\n      }),\n    [isScrolling, isDragging],\n  )\n\n  return (\n    <div\n      className={styles.container}\n      style={{\n        ...ContainerCss({\n          minDisplayCount,\n          displayCount,\n          slideAnchors,\n        }),\n        ...style,\n      }}\n      ref={containerRef}\n    >\n      <div className={styles.slidesAndArrowsContainer} onMouseLeave={onTouchEnd}>\n        {showArrows && (\n          <RenderArrows\n            isLeft={true}\n            isRight={false}\n            isHidden={isScrolling || isDragging || !showLeftArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowLeftProps}\n          />\n        )}\n        <div\n          ref={slideContainerRef}\n          className={styles.slideContainer}\n          style={{\n            ...slideContainerCss,\n            ...slideContainerStyle,\n          }}\n          onTouchStart={onTouchStart}\n          onTouchMove={onTouchMove}\n          onTouchEnd={onTouchEnd}\n          onTouchCancel={onTouchEnd}\n          onMouseDown={onTouchStart}\n          onMouseMove={onTouchMove}\n          onMouseUp={onTouchEnd}\n          onWheel={onScroll}\n        >\n          {slides.map((slide, i) => (\n            <div\n              style={{ paddingRight: `${i === slides.length ? 0 : gridGap}px`, ...slideStyle }}\n              ref={slidesRefs[i]}\n              key={i}\n            >\n              {slide}\n            </div>\n          ))}\n        </div>\n        {showArrows && (\n          <RenderArrows\n            isLeft={false}\n            isRight={true}\n            isHidden={isScrolling || isDragging || !showRightArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowRightProps}\n          />\n        )}\n      </div>\n      {showIndexes && (\n        <RenderIndexes\n          startIndex={index.left}\n          endIndex={index.right}\n          indexesPerRow={indexesPerRow || slideCount}\n          slideAnchors={slideAnchors}\n          scrollBy={onArrowClick}\n          indexContainerProps={indexContainerProps}\n          indexProps={indexProps}\n        />\n      )}\n    </div>\n  )\n}\n"],"names":["css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","getClientXOffset","e","touches","clientX","calcMinWidth","slideAnchors","count","length","reduce","acc","start","i","groupWidth","Math","min","end","ContainerCss","displayCount","minDisplayCount","minWidth","width","Arrow","isLeft","isRight","isHidden","scrollBy","arrowProps","arrowIconProps","arrowClassName","useMemo","styles","className","onClick","useCallback","callback","scrollCount","preventDefault","stopPropagation","iconClassName","React","Indexes","startIndex","endIndex","indexesPerRow","indexContainerProps","indexProps","containerRef","useRef","containerClassName","gap","map","_","_extends","key","backgroundColor","borderWidth","isScrollable","isDraggable","hasDragMomentum","dragMomentumSpeed","dragMomentumDecay","gridGap","showArrows","renderArrows","RenderArrows","arrowLeftProps","arrowRightProps","scrollSpeed","showIndexes","renderIndexes","RenderIndexes","slideContainerStyle","slideStyle","children","momentumTimeoutId","currentDragSpeed","resizeObserverRef","slides","Children","toArray","slideCount","slidesRefs","Array","fill","createRef","setSlideAnchors","useState","slideContainerRef","getTranslateOffset","newIndex","newSlideAnchors","index","setIndexState","left","right","indexRef","setIndex","current","maxIndex","setMaxIndex","isDragging","setIsDragging","isScrolling","setIsScrolling","isMomentum","translateOffset","touchStartRef","touchEndRef","scrollDebounceId","minScrollX","showLeftArrow","showRightArrow","clientWidth","getBoundIndex","newMaxIndex","max","getScrollIndex","newTranslateOffset","currentOffset","setTranslateOffset","offset","requestAnimationFrame","transform","onResize","slideRefs","push","calculateAnchors","containerWidth","lastEnd","findIndex","newLeftIndex","newScrollIndex","useLayoutEffect","disconnect","ResizeObserver","forEach","observe","useEffect","window","addEventListener","removeEventListener","onArrowClick","indexOffset","newBoundIndex","onTouchStart","cancelAnimationFrame","xOffset","onTouchMove","delta","onTouchEnd","momentumFunc","speed","abs","onScroll","scrollDelta","deltaX","deltaY","scrollDirection","sign","debounceFunc","finalTranslateOffset","finalBoundIndex","clearTimeout","setTimeout","slideContainerCss","transition","SlidesContainerCss","onMouseLeave","onTouchCancel","onMouseDown","onMouseMove","onMouseUp","onWheel","slide","paddingRight"],"mappings":"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"}