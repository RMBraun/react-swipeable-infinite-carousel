{"version":3,"file":"index.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/components/Carousel.jsx","../src/components/Arrows.jsx","../src/components/Indexes.jsx"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","/* eslint-disable react/prop-types */\nimport React, { useState, useMemo, useRef, useCallback, useEffect, useLayoutEffect } from 'react'\nimport styles from './Carousel.module.css'\n\nconst getClientXOffset = (e) => e?.touches?.[0]?.clientX || e?.clientX || 0\n\nconst calculateAnchors = (slideRefs = [], gridGap) =>\n  slideRefs.reduce((acc, ref, i) => {\n    if (ref?.current) {\n      const width = ref.current.clientWidth - gridGap\n      const start = i === 0 ? 0 : acc[i - 1].end + gridGap\n      const end = start + width\n      acc.push({ start, end, width })\n    }\n    return acc\n  }, [])\n\nconst calcMinWidth = (slideAnchors, count) =>\n  slideAnchors?.length && count && count > 0\n    ? slideAnchors.reduce((acc, { start }, i) => {\n        const groupWidth = slideAnchors[Math.min(i + count - 1, slideAnchors.length - 1)].end - start\n\n        return groupWidth > acc ? groupWidth : acc\n      }, 0)\n    : 0\n\nconst ContainerCss = ({ displayCount, minDisplayCount, slideAnchors }) => {\n  const minWidth = calcMinWidth(slideAnchors, minDisplayCount)\n  const width = calcMinWidth(slideAnchors, displayCount)\n\n  return {\n    minWidth: minWidth > 0 ? `${minWidth}px` : 'auto',\n    width: width > 0 ? `${width}px` : '100%',\n  }\n}\n\nexport const Carousel = ({\n  isInfinite = false,\n  startIndex = 0,\n  isScrollable = true,\n  isDraggable = true,\n  hasDragMomentum = true,\n  dragMomentumSpeed = 25,\n  dragMomentumDecay = 0.98,\n  minDisplayCount = 0,\n  displayCount = 0,\n  gridGap = 10,\n  arrows: RenderArrows,\n  arrowLeftProps = {},\n  arrowRightProps = {},\n  scrollSpeed = 75,\n  indexesPerRow = 0,\n  indexes: RenderIndexes,\n  indexContainerProps = {},\n  indexProps = {},\n  style = {},\n  slideContainerStyle = {},\n  slideStyle = {},\n  children,\n}) => {\n  const momentumDebounceId = useRef()\n\n  const transitionDebounceId = useRef()\n\n  const areArrowsLocked = useRef(false)\n\n  const currentDragSpeed = useRef(0)\n\n  const resizeObserverRef = useRef()\n\n  const rawSlides = React.Children.toArray(children) || []\n\n  const [clonesLength, setClonesLength] = useState(isInfinite ? rawSlides.length : 0)\n\n  const slides = useMemo(\n    () =>\n      isInfinite && clonesLength\n        ? [\n            ...rawSlides.slice(rawSlides.length - clonesLength, rawSlides.length),\n            ...rawSlides,\n            ...rawSlides.slice(0, clonesLength),\n          ]\n        : rawSlides,\n    [rawSlides.length, isInfinite, clonesLength],\n  )\n\n  const slideCount = slides.length\n\n  const slidesRefs = useMemo(\n    () =>\n      Array(slideCount)\n        .fill(null)\n        .map((_, i) => slidesRefs?.[i] || React.createRef()),\n    [slideCount],\n  )\n\n  const [slideAnchors, setSlideAnchors] = useState([])\n\n  const coreSlideAnchors = useMemo(\n    () => (isInfinite ? slideAnchors.slice(clonesLength, slideAnchors.length - clonesLength) : slideAnchors),\n    [slideAnchors, slideAnchors.length, isInfinite],\n  )\n\n  const containerRef = useRef(null)\n\n  const slideContainerRef = useRef(null)\n\n  const getTranslateOffset = useCallback(\n    (newIndex, newSlideAnchors = slideAnchors) => {\n      const start = newSlideAnchors?.[newIndex]?.start\n      return start != null ? -1 * start : 0\n    },\n\n    [slideAnchors],\n  )\n\n  const [index, setIndexState] = useState({ left: startIndex + clonesLength, right: startIndex + clonesLength })\n\n  const activeIndexes = useMemo(() => {\n    if (index?.left != null && index?.right != null) {\n      return Array(index.right - index.left + 1)\n        .fill(index.left)\n        .map((_, i) => (index.left + i - clonesLength) % rawSlides.length)\n    } else {\n      return []\n    }\n  }, [index?.left, index?.right, clonesLength])\n\n  const indexRef = useRef(index)\n\n  const [maxIndex, setMaxIndex] = useState(slideCount)\n\n  const [isDragging, setIsDragging] = useState(false)\n\n  const [isScrolling, setIsScrolling] = useState(true)\n\n  const isMomentum = useRef(false)\n\n  const translateOffset = useRef(() => getTranslateOffset(index.left))\n\n  const touchStartRef = useRef(0)\n\n  const touchEndRef = useRef(0)\n\n  const scrollDebounceId = useRef()\n\n  const maxScrollX = 0\n\n  const minScrollX = useMemo(() => {\n    const start = slideAnchors?.[maxIndex]?.start\n\n    return start != null ? -1 * start : 0\n  }, [slideAnchors, slideCount, maxIndex])\n\n  const showLeftArrow = isInfinite || index.left !== 0\n\n  const showRightArrow =\n    isInfinite ||\n    (translateOffset.current != null && containerRef.current != null && slideAnchors?.[slideCount - 1] != null\n      ? -1 * translateOffset.current + containerRef.current.clientWidth < slideAnchors?.[slideCount - 1].end\n      : true)\n\n  const getBoundIndex = useCallback(\n    (newIndex, newMaxIndex = maxIndex) => Math.max(0, Math.min(newMaxIndex, newIndex)),\n    [maxIndex],\n  )\n\n  const getScrollIndex = useCallback(\n    (newTranslateOffset, newSlideAnchors = slideAnchors) => {\n      const currentOffset = -1 * newTranslateOffset\n\n      const newIndex = newSlideAnchors.reduce(\n        (acc, { start, end, width }, i) => {\n          acc.left = currentOffset >= start ? (currentOffset >= start + width / 2 ? i + 1 : i) : acc.left\n          acc.right =\n            containerRef.current != null\n              ? currentOffset + containerRef.current.clientWidth >= end\n                ? i\n                : acc.right\n              : slideCount - 1\n\n          return acc\n        },\n        {\n          left: 0,\n          right: 0,\n        },\n      )\n\n      return {\n        left: getBoundIndex(newIndex.left),\n        right: Math.max(Math.min(slideCount - 1, newIndex.right), newIndex.left),\n      }\n    },\n    [slideCount, slideAnchors, getBoundIndex],\n  )\n\n  const setTranslateOffset = useCallback(\n    ({ offset, index, newSlideAnchors = slideAnchors, newClonesLength = clonesLength }) => {\n      requestAnimationFrame(() => {\n        if (!slideContainerRef.current) {\n          return\n        }\n\n        let boundOffset = offset\n\n        if (isInfinite && newClonesLength && newSlideAnchors.length) {\n          const rightAnchor = newSlideAnchors[newSlideAnchors.length - newClonesLength - 1].end + gridGap\n          const leftAnchor = newSlideAnchors[newClonesLength].start\n\n          if (offset + rightAnchor < 0) {\n            boundOffset = offset + rightAnchor - leftAnchor\n          } else if (offset + leftAnchor > 0) {\n            boundOffset = offset + leftAnchor - rightAnchor\n          }\n        }\n\n        const newIndex = index == null ? getScrollIndex(boundOffset) : index\n\n        if (transitionDebounceId.current) {\n          cancelAnimationFrame(transitionDebounceId.current)\n        }\n\n        if (isScrolling || isDragging) {\n          slideContainerRef.current.style.transitionDuration = '0ms'\n        }\n\n        slideContainerRef.current.style.transform = `translate(${boundOffset}px)`\n\n        transitionDebounceId.current = requestAnimationFrame(() => {\n          slideContainerRef.current.style.transitionDuration = '500ms'\n        })\n\n        translateOffset.current = boundOffset\n        setIndexState(newIndex)\n      })\n    },\n    [\n      gridGap,\n      isScrolling,\n      isDragging,\n      slideAnchors,\n      slideAnchors?.length,\n      clonesLength,\n      getScrollIndex,\n      setIndexState,\n      getScrollIndex,\n    ],\n  )\n\n  const calcClonesLength = (newSlideAnchors) => {\n    if (!isInfinite) {\n      return 0\n    }\n\n    const containerWidth = slideContainerRef.current.clientWidth\n\n    const coreSlideAnchors = isInfinite\n      ? newSlideAnchors.slice(clonesLength, newSlideAnchors.length - clonesLength)\n      : newSlideAnchors\n\n    const leftCount = coreSlideAnchors.reduce(\n      (acc, { width }, i) => {\n        acc.width = acc.width + width\n\n        if (acc.index == null && acc.width > containerWidth) {\n          acc.index = i + 1\n        }\n\n        return acc\n      },\n      {\n        width: 0,\n        index: null,\n      },\n    ).index\n\n    const rightCount = coreSlideAnchors.reduceRight(\n      (acc, { width }, i) => {\n        acc.width = acc.width + width\n\n        if (acc.index == null && acc.width > containerWidth) {\n          acc.index = coreSlideAnchors.length - i\n        }\n\n        return acc\n      },\n      {\n        width: 0,\n        index: null,\n      },\n    ).index\n\n    return Math.max(leftCount, rightCount, 1)\n  }\n\n  const onResize = () => {\n    const newSlideAnchors = calculateAnchors(slidesRefs, gridGap)\n    if (newSlideAnchors?.length) {\n      const containerWidth = slideContainerRef.current.clientWidth\n\n      const newClonesLength = calcClonesLength(newSlideAnchors)\n\n      const lastEnd = newSlideAnchors[newSlideAnchors.length - 1].end\n\n      const newMaxIndex = getBoundIndex(\n        newSlideAnchors.findIndex(({ start }) => start + containerWidth >= lastEnd),\n        newSlideAnchors.length - 1,\n      )\n      const newLeftIndex = getBoundIndex(indexRef.current.left + newClonesLength, newMaxIndex)\n      const newTranslateOffset = getTranslateOffset(newLeftIndex, newSlideAnchors)\n      const newScrollIndex = getScrollIndex(newTranslateOffset, newSlideAnchors)\n\n      setClonesLength(newClonesLength)\n      setIndexState(newScrollIndex)\n      setSlideAnchors(newSlideAnchors)\n      setMaxIndex(newMaxIndex)\n      setTranslateOffset({ offset: newTranslateOffset, index: newScrollIndex })\n    }\n  }\n\n  useLayoutEffect(() => {\n    if (resizeObserverRef.current) {\n      resizeObserverRef.current.disconnect()\n    }\n\n    resizeObserverRef.current = new ResizeObserver(onResize)\n    resizeObserverRef.current.observe(containerRef.current)\n    slidesRefs.forEach(({ current }) => resizeObserverRef.current.observe(current))\n\n    onResize()\n  }, [slideCount, clonesLength, minDisplayCount, displayCount, gridGap, isInfinite])\n\n  useEffect(() => {\n    setIsScrolling(false)\n\n    if (isInfinite) {\n      onResize()\n    }\n  }, [])\n\n  const onArrowClick = useCallback(\n    (indexOffset) => {\n      if (!areArrowsLocked.current) {\n        areArrowsLocked.current = true\n        let newBoundIndex = getBoundIndex(index.left + indexOffset)\n\n        if (isInfinite) {\n          const wrappedIndex =\n            newBoundIndex >= slideAnchors.length - clonesLength\n              ? newBoundIndex - rawSlides.length - 1\n              : newBoundIndex < clonesLength - 1\n              ? rawSlides.length + 1 + newBoundIndex\n              : null\n\n          if (wrappedIndex != null) {\n            slideContainerRef.current.style.transitionDuration = '0ms'\n\n            const wrappedTranslateOffset = -slideAnchors[wrappedIndex].start\n            slideContainerRef.current.style.transform = `translate(${wrappedTranslateOffset}px)`\n\n            translateOffset.current = wrappedTranslateOffset\n            newBoundIndex = getBoundIndex(wrappedIndex + indexOffset)\n          }\n        }\n\n        requestAnimationFrame(() => {\n          slideContainerRef.current.style.transitionDuration = '500ms'\n          requestAnimationFrame(() => {\n            if (newBoundIndex !== index.left) {\n              const newTranslateOffset = getTranslateOffset(newBoundIndex)\n              const newScrollIndex = getScrollIndex(newTranslateOffset)\n              setIndexState(newScrollIndex)\n\n              slideContainerRef.current.addEventListener(\n                'transitionend',\n                () => {\n                  areArrowsLocked.current = false\n                },\n                { once: true },\n              )\n\n              slideContainerRef.current.style.transform = `translate(${newTranslateOffset}px)`\n\n              translateOffset.current = newTranslateOffset\n            } else {\n              areArrowsLocked.current = false\n            }\n          })\n        })\n      }\n    },\n    [\n      slideAnchors,\n      isInfinite,\n      index,\n      slideCount,\n      getScrollIndex,\n      getTranslateOffset,\n      setTranslateOffset,\n      getBoundIndex,\n      setIndexState,\n    ],\n  )\n\n  const onTouchStart = useCallback(\n    (e) => {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (areArrowsLocked.current || !isDraggable || isScrolling || e.touches?.length > 1) {\n        return\n      }\n\n      isMomentum.current = false\n      setIsDragging(true)\n\n      const xOffset = getClientXOffset(e)\n      touchStartRef.current = xOffset\n      touchEndRef.current = xOffset\n    },\n    [isDraggable, isScrolling, setIsDragging],\n  )\n\n  const onTouchMove = useCallback(\n    (e) => {\n      e.stopPropagation()\n\n      if (areArrowsLocked.current || isMomentum.current || !isDraggable || !isDragging || isScrolling) {\n        return\n      }\n\n      touchEndRef.current = getClientXOffset(e)\n      const delta = touchStartRef.current - touchEndRef.current\n      touchStartRef.current = touchEndRef.current\n\n      currentDragSpeed.current = delta\n\n      if (delta !== 0) {\n        setTranslateOffset({ offset: translateOffset.current - delta })\n      }\n    },\n    [isDraggable, isScrolling, isDragging, setTranslateOffset],\n  )\n\n  const onTouchEnd = useCallback(\n    (e) => {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (areArrowsLocked.current || !isDraggable || isScrolling || e.touches?.length > 0) {\n        return\n      }\n\n      if (hasDragMomentum) {\n        isMomentum.current = true\n\n        const momentumFunc = (speed) => {\n          currentDragSpeed.current = speed\n          momentumDebounceId.current = requestAnimationFrame(() => {\n            const newTranslateOffset = translateOffset.current - speed\n\n            if (Math.abs(speed) <= 1 || newTranslateOffset >= maxScrollX || newTranslateOffset <= minScrollX) {\n              isMomentum.current = false\n              setIsDragging(false)\n              currentDragSpeed.current = 0\n            } else {\n              setTranslateOffset({ offset: newTranslateOffset })\n              momentumFunc(speed * dragMomentumDecay)\n            }\n          })\n        }\n\n        momentumFunc(\n          currentDragSpeed.current < 0\n            ? Math.max(currentDragSpeed.current, -dragMomentumSpeed)\n            : Math.min(currentDragSpeed.current, dragMomentumSpeed),\n        )\n      } else {\n        setIsDragging(false)\n      }\n    },\n    [\n      hasDragMomentum,\n      dragMomentumSpeed,\n      dragMomentumDecay,\n      minScrollX,\n      maxScrollX,\n      isDraggable,\n      isScrolling,\n      setIsDragging,\n      setTranslateOffset,\n    ],\n  )\n\n  const onScroll = useCallback(\n    (e) => {\n      if (areArrowsLocked.current || !isScrollable || isDragging) {\n        return\n      }\n\n      const isWheel = e.deltaX === 0 && Math.abs(e.deltaY) > 0\n      const scrollDelta = isWheel ? -1 * e.deltaY : e.deltaX\n      const scrollDirection = Math.sign(scrollDelta)\n\n      if (\n        (translateOffset.current >= maxScrollX && scrollDirection === -1) ||\n        (translateOffset.current <= minScrollX && scrollDirection === 1)\n      ) {\n        setIsScrolling(false)\n        return\n      }\n\n      if (!isScrolling) {\n        setIsScrolling(true)\n      }\n\n      const newTranslateOffset =\n        translateOffset.current - scrollDirection * Math.min(scrollSpeed, Math.abs(scrollDelta))\n\n      const debounceFunc = () => {\n        setIsScrolling(false)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      if (!isInfinite && newTranslateOffset >= maxScrollX) {\n        setTranslateOffset({ offset: maxScrollX })\n      } else if (!isInfinite && newTranslateOffset <= minScrollX) {\n        setTranslateOffset({ offset: minScrollX })\n      } else {\n        setTranslateOffset({ offset: newTranslateOffset })\n\n        scrollDebounceId.current = setTimeout(debounceFunc, 100)\n      }\n    },\n    [\n      isInfinite,\n      isScrollable,\n      scrollSpeed,\n      isScrolling,\n      minScrollX,\n      translateOffset,\n      isDragging,\n      setIsScrolling,\n      setTranslateOffset,\n    ],\n  )\n\n  useEffect(() => {\n    if (!areArrowsLocked.current && !(isDraggable && isDragging) && !(isScrollable && isScrolling)) {\n      if (momentumDebounceId.current) {\n        cancelAnimationFrame(momentumDebounceId.current)\n      }\n\n      if (scrollDebounceId.current) {\n        clearTimeout(scrollDebounceId.current)\n      }\n\n      const newTranslateOffset = getTranslateOffset(index.left)\n      setTranslateOffset({ offset: newTranslateOffset })\n\n      touchStartRef.current = 0\n      touchEndRef.current = 0\n    }\n  }, [isDragging, isDraggable, isScrolling, isScrollable])\n\n  const containerCss = useMemo(\n    () =>\n      ContainerCss({\n        minDisplayCount,\n        displayCount,\n        slideAnchors,\n      }),\n    [slideAnchors, slideAnchors?.length, minDisplayCount, displayCount],\n  )\n\n  return (\n    <div\n      className={styles.container}\n      style={{\n        ...containerCss,\n        ...style,\n      }}\n      ref={containerRef}\n    >\n      <div className={styles.slidesAndArrowsContainer} onMouseLeave={onTouchEnd}>\n        {RenderArrows ? (\n          <RenderArrows\n            isLeft={true}\n            isRight={false}\n            isHidden={isScrolling || isDragging || !showLeftArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowLeftProps}\n          />\n        ) : null}\n        <div\n          ref={slideContainerRef}\n          className={styles.slideContainer}\n          style={slideContainerStyle}\n          onTouchStart={onTouchStart}\n          onTouchMove={onTouchMove}\n          onTouchEnd={onTouchEnd}\n          onTouchCancel={onTouchEnd}\n          onMouseDown={onTouchStart}\n          onMouseMove={onTouchMove}\n          onMouseUp={onTouchEnd}\n          onWheel={onScroll}\n        >\n          {slides.map((slide, i) => (\n            <div\n              style={{ paddingRight: `${!isInfinite && i === slides.length - 1 ? 0 : gridGap}px`, ...slideStyle }}\n              ref={slidesRefs[i]}\n              key={i}\n            >\n              {slide}\n            </div>\n          ))}\n        </div>\n        {RenderArrows ? (\n          <RenderArrows\n            isLeft={false}\n            isRight={true}\n            isHidden={isScrolling || isDragging || !showRightArrow}\n            scrollBy={onArrowClick}\n            arrowProps={arrowRightProps}\n          />\n        ) : null}\n      </div>\n      {RenderIndexes ? (\n        <RenderIndexes\n          startIndex={index.left - clonesLength}\n          endIndex={index.right - clonesLength}\n          activeIndexes={activeIndexes}\n          indexesPerRow={indexesPerRow || rawSlides.length}\n          slideAnchors={coreSlideAnchors}\n          scrollBy={onArrowClick}\n          indexContainerProps={indexContainerProps}\n          indexProps={indexProps}\n        />\n      ) : null}\n    </div>\n  )\n}\n","import React, { useCallback, useMemo } from 'react'\nimport styles from './Arrows.module.css'\n\nexport const Arrows = ({ isLeft, isHidden, scrollBy, arrowProps, arrowIconProps }) => {\n  const arrowClassName = useMemo(\n    () =>\n      `${styles.arrow} ${isLeft ? styles.leftArrow : styles.rightArrow} ${isHidden ? styles.isArrowHidden : ''} ${\n        arrowProps?.className || ''\n      }`,\n    [arrowProps?.className, isLeft, isHidden],\n  )\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      e.preventDefault()\n      e.stopPropagation()\n\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [arrowProps?.onClick, scrollBy, isLeft],\n  )\n\n  const iconClassName = useMemo(\n    () =>\n      `${styles.arrowIcon} ${isLeft ? styles.leftArrowIcon : styles.rightArrowIcon} ${arrowIconProps?.className || ''}`,\n    [arrowIconProps?.className, isLeft],\n  )\n\n  return (\n    <button {...arrowProps} className={arrowClassName} onClick={onClick(arrowProps?.onClick, isLeft ? -1 : 1)}>\n      <span {...arrowIconProps} className={iconClassName} />\n    </button>\n  )\n}\n","import React, { useCallback, useMemo, useRef } from 'react'\nimport styles from './Indexes.module.css'\n\nexport const Indexes = ({\n  activeIndexes,\n  startIndex,\n  indexesPerRow,\n  slideAnchors,\n  scrollBy,\n  indexContainerProps,\n  indexProps,\n}) => {\n  const containerRef = useRef()\n  const gap = 5\n  const borderWidth = 2\n  const width = useMemo(() => `calc((100% - ${(indexesPerRow - 1) * gap}px) / ${indexesPerRow})`, [indexesPerRow])\n\n  const containerClassName = useMemo(\n    () => `${styles.indexContainer} ${indexContainerProps?.className || ''}`,\n    [indexContainerProps?.className],\n  )\n\n  const iconClassName = useMemo(() => `${styles.index} ${indexProps?.className || ''}`, [indexProps?.className])\n\n  const onClick = useCallback(\n    (callback, scrollCount) => (e) => {\n      if (typeof callback === 'function') {\n        callback(e)\n      }\n\n      scrollBy(scrollCount)\n    },\n    [scrollBy],\n  )\n\n  return (\n    <div\n      {...indexContainerProps}\n      ref={containerRef}\n      className={containerClassName}\n      style={{ gap: `${gap}px`, ...indexContainerProps?.style }}\n    >\n      {slideAnchors?.map((_, i) => (\n        <button\n          key={i}\n          {...indexProps}\n          className={iconClassName}\n          style={{\n            backgroundColor: activeIndexes.includes(i) ? 'black' : 'transparent',\n            width,\n            borderWidth: `${borderWidth}px`,\n            ...indexProps?.style,\n          }}\n          onClick={onClick(indexProps?.onClick, i - startIndex)}\n        />\n      ))}\n    </div>\n  )\n}\n"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","getClientXOffset","e","touches","clientX","calcMinWidth","slideAnchors","count","length","reduce","acc","start","i","groupWidth","Math","min","end","isLeft","isHidden","scrollBy","arrowProps","arrowIconProps","arrowClassName","useMemo","styles","className","onClick","useCallback","callback","scrollCount","preventDefault","stopPropagation","iconClassName","React","isInfinite","startIndex","isScrollable","isDraggable","hasDragMomentum","dragMomentumSpeed","dragMomentumDecay","minDisplayCount","displayCount","gridGap","arrows","RenderArrows","arrowLeftProps","arrowRightProps","scrollSpeed","indexesPerRow","indexes","RenderIndexes","indexContainerProps","indexProps","slideContainerStyle","slideStyle","children","momentumDebounceId","useRef","transitionDebounceId","areArrowsLocked","currentDragSpeed","resizeObserverRef","rawSlides","Children","toArray","clonesLength","setClonesLength","useState","slides","slice","slideCount","slidesRefs","Array","fill","map","_","createRef","setSlideAnchors","coreSlideAnchors","containerRef","slideContainerRef","getTranslateOffset","newIndex","newSlideAnchors","index","setIndexState","left","right","activeIndexes","indexRef","maxIndex","setMaxIndex","isDragging","setIsDragging","isScrolling","setIsScrolling","isMomentum","translateOffset","touchStartRef","touchEndRef","scrollDebounceId","minScrollX","showLeftArrow","showRightArrow","current","clientWidth","getBoundIndex","newMaxIndex","max","getScrollIndex","newTranslateOffset","currentOffset","width","setTranslateOffset","offset","newClonesLength","requestAnimationFrame","boundOffset","rightAnchor","leftAnchor","cancelAnimationFrame","transitionDuration","transform","onResize","slideRefs","push","calculateAnchors","containerWidth","leftCount","rightCount","reduceRight","calcClonesLength","lastEnd","findIndex","newLeftIndex","newScrollIndex","useLayoutEffect","disconnect","ResizeObserver","observe","forEach","useEffect","onArrowClick","indexOffset","newBoundIndex","wrappedIndex","wrappedTranslateOffset","addEventListener","once","onTouchStart","xOffset","onTouchMove","delta","onTouchEnd","momentumFunc","speed","abs","onScroll","scrollDelta","deltaX","deltaY","scrollDirection","sign","debounceFunc","clearTimeout","setTimeout","containerCss","minWidth","ContainerCss","onMouseLeave","isRight","onTouchCancel","onMouseDown","onMouseMove","onMouseUp","onWheel","slide","paddingRight","key","endIndex","containerClassName","gap","_extends","backgroundColor","includes","borderWidth"],"mappings":"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"}